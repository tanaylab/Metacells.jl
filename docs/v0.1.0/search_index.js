var documenterSearchIndex = {"docs":
[{"location":"identify_genes.html#Identify-Genes","page":"Identify Genes","title":"Identify Genes","text":"","category":"section"},{"location":"identify_genes.html","page":"Identify Genes","title":"Identify Genes","text":"Metacells.IdentifyGenes\nMetacells.IdentifyGenes.compute_genes_divergence!\nMetacells.IdentifyGenes.identify_marker_genes!\nMetacells.IdentifyGenes.rank_marker_genes!\nMetacells.IdentifyGenes.identify_uncorrelated_genes!\nMetacells.IdentifyGenes.identify_covered_genes!\nMetacells.IdentifyGenes.identify_skeleton_genes!","category":"page"},{"location":"identify_genes.html#Metacells.IdentifyGenes","page":"Identify Genes","title":"Metacells.IdentifyGenes","text":"Identify special genes.\n\n\n\n\n\n","category":"module"},{"location":"identify_genes.html#Metacells.IdentifyGenes.compute_genes_divergence!","page":"Identify Genes","title":"Metacells.IdentifyGenes.compute_genes_divergence!","text":"function compute_genes_divergence!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    min_divergent_gene_range_fold::Real = ```6```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nCompute a divergence factor for all genes. This factor is typically 0.0 for most genes (and is always below 1.0). Genes that have a wide range of expression are given a higher divergence factor. When looking for significant differences in gene expressions, the divergence factor is used to scale down the difference, to compensate for the gene's inherent wider expression range. Specifically, we take the raw fold factor and multiply it by (1.0 - divergence).\n\nThis works as follows:\n\nCompute the minimal and maximal expression level of each gene.\nCompute the fold factor (log2 of maximal over minimal value, using the gene_fraction_regularization.\nThe raw factor of the gene is the ratio between the fold factor and the min_divergent_gene_range_fold. If this is higher than 1, we set the divergence factor accordingly.\n\nnote: Note\nIdeally, all code that uses the manual is_noisy mask should be modified to use the divergence factor instead.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nMatrices\n\ngene, metacell @ fraction::Union{Float32, Float64} (required): The estimated fraction of the UMIs of each gene in each metacell.\n\nOutputs\n\nVectors\n\ngene @ divergence::Union{Float32, Float64} (guaranteed): Scale fold factors of each gene by multiplying with (1 - divergence) of the gene.\n\n\n\n\n\n","category":"function"},{"location":"identify_genes.html#Metacells.IdentifyGenes.identify_marker_genes!","page":"Identify Genes","title":"Metacells.IdentifyGenes.identify_marker_genes!","text":"function identify_marker_genes!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    min_marker_gene_range_fold::Real = ```2```,\n    min_marker_gene_max_fraction::AbstractFloat = ```0.0001```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nIdentify the genes that distinguish at least one metacell from the rest. Such genes are called \"marker\" genes as they (potentially) mark specific cell states. If overwrite, will overwrite an existing is_marker mask.\n\nCompute the minimal and maximal expression level of each gene.\nCompute the fold factor (log2 of maximal over minimal value, using the gene_fraction_regularization.\nIdentify as markers genes whose adjusted fold factor is at least min_marker_gene_range_fold, and whose maximal expression is at least min_marker_gene_max_fraction.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nMatrices\n\ngene, metacell @ fraction::Union{Float32, Float64} (required): The estimated fraction of the UMIs of each gene in each metacell.\n\nOutputs\n\nVectors\n\ngene @ is_marker::Bool (guaranteed): A mask of genes that distinguish between cell states.\n\n\n\n\n\n","category":"function"},{"location":"identify_genes.html#Metacells.IdentifyGenes.rank_marker_genes!","page":"Identify Genes","title":"Metacells.IdentifyGenes.rank_marker_genes!","text":"function rank_marker_genes!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nCompute the relative ranks of marker genes.\n\nCompute the log base 2 of the expression of the marker genes in the metacells (using the gene_fraction_regularization).\nCompute the median of this for each gene across all the metacells.\nCompute the per-marker-per-metacell fold factor (absolute difference of the log expression from the median).\nRank the markers for each metacell (1 having the largest fold factor relative to the median).\nFor each markers, give it a priority which is a tuple of (1) the minimal rank it has in all metacells (2) the maximal fold it has in metacells where it has that rank (negated).\nSort the markers according to this priority.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ is_marker::Bool (required): A mask of genes that distinguish between cell states.\n\nMatrices\n\ngene, metacell @ fraction::Union{Float32, Float64} (required): The estimated fraction of the UMIs of each gene in each metacell.\n\nOutputs\n\nVectors\n\ngene @ marker_rank::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The ralative ranks of the marker genes.\n\n\n\n\n\n","category":"function"},{"location":"identify_genes.html#Metacells.IdentifyGenes.identify_uncorrelated_genes!","page":"Identify Genes","title":"Metacells.IdentifyGenes.identify_uncorrelated_genes!","text":"function identify_uncorrelated_genes!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    correlation_confidence::AbstractFloat = ```0.99```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nIdentify genes that are correlated with other gene(s). Such genes are good candidates for looking for groups of genes that act together. If overwrite, will overwrite an existing is_correlated mask.\n\nCompute the log base 2 of the genes expression in each metacell (using the gene_fraction_regularization).\nCorrelate this between all the pairs of genes.\nFor each gene, shuffle its values along all metacells, and again correlate this between all the pairs of genes.\nFind the maximal absolute correlation for each gene in both cases (that is, strong anti-correlation also counts).\nFind the correlation_confidence quantile correlation of the shuffled data.\nIdentify the genes that have at least that level of correlations in the unshuffled data.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nMatrices\n\ngene, metacell @ fraction::Union{Float32, Float64} (required): The estimated fraction of the UMIs of each gene in each metacell.\n\nOutputs\n\nVectors\n\ngene @ is_uncorrelated::Bool (guaranteed): A mask of genes that are not correlated with other gene(s).\n\n\n\n\n\n","category":"function"},{"location":"identify_genes.html#Metacells.IdentifyGenes.identify_covered_genes!","page":"Identify Genes","title":"Metacells.IdentifyGenes.identify_covered_genes!","text":"function identify_covered_genes!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nIdentify the genes that will be approximated by the local linear programs. Picking them is simple: we cover all marker genes that are not lateral and not uncorrelated.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ is_marker::Bool (required): A mask of genes that distinguish between cell states.\n\ngene @ is_lateral::Bool (required): A mask of genes that are lateral to the biological behaviors of interest.\n\ngene @ is_uncorrelated::Bool (required): A mask of genes that are not correlated with other gene(s).\n\nOutputs\n\nVectors\n\ngene @ is_covered::Bool (guaranteed): A mask of genes that are covered by the local linear program.\n\n\n\n\n\n","category":"function"},{"location":"identify_genes.html#Metacells.IdentifyGenes.identify_skeleton_genes!","page":"Identify Genes","title":"Metacells.IdentifyGenes.identify_skeleton_genes!","text":"function identify_skeleton_genes!(\n    daf::DafWriter;\n    max_skeleton_genes::Integer = ```200```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nIdentify the skeleton genes that will be used to predict the rest of the (covered) genes. We just pick the max_skeleton_genes that have the lowest marker_rank out of the covered genes.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\ngene @ marker_rank::Union{UInt16, UInt32, UInt64, UInt8} (required): The ralative ranks of the marker genes.\n\nOutputs\n\nVectors\n\ngene @ is_skeleton::Bool (guaranteed): A mask of genes that are used to predict the values of the rest of the (covered) genes.\n\n\n\n\n\n","category":"function"},{"location":"identify_genes.html#Index","page":"Identify Genes","title":"Index","text":"","category":"section"},{"location":"identify_genes.html","page":"Identify Genes","title":"Identify Genes","text":"Pages = [\"identify_genes.md\"]","category":"page"},{"location":"blocks.html#Blocks","page":"Blocks","title":"Blocks","text":"","category":"section"},{"location":"blocks.html","page":"Blocks","title":"Blocks","text":"Metacells.Blocks\nMetacells.Blocks.compute_covered_fractions!\nMetacells.Blocks.compute_blocks!\nMetacells.Blocks.sharpen_metacells!","category":"page"},{"location":"blocks.html#Metacells.Blocks","page":"Blocks","title":"Metacells.Blocks","text":"Approximate the manifold of actual cell states (captured by metacells) using linear programs in each local region.\n\n\n\n\n\n","category":"module"},{"location":"blocks.html#Metacells.Blocks.compute_covered_fractions!","page":"Blocks","title":"Metacells.Blocks.compute_covered_fractions!","text":"function compute_covered_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```2.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nCompute normalized fractions for each metacell based only on the covered genes. By changing the denominator to only this smaller set of genes, we remove effects of possibly high-expression \"irrelevant\" gene programs (e.g., cell cycle). In general whenever we talk about gene \"fractions\" we have to keep in mind what is the total the fractions are out of, and ensure it is fit for purpose (and, of course, ensure the same divergence factors are used for all the data). Here we are going to be using these fractions for creating a distance measure in the manifold, which will be used for both deciding what is a \"local\" region and for estimating errors of reconsctructing the manifold, taking into consideration only the covered genes.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\ngene @ divergence::Union{Float32, Float64} (optional): Scale fold factors of each gene by multiplying with (1 - divergence) of the gene.\n\nMatrices\n\ngene, metacell @ total_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\ngene, metacell @ fraction::Union{Float32, Float64} (required): The estimated fraction of the UMIs of each gene in each metacell.\n\nOutputs\n\nVectors\n\nmetacell @ covered_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of the covered genes in each metacell.\n\nMatrices\n\ngene, metacell @ covered_fraction::Union{Float32, Float64} (guaranteed): The relative fraction of covered genes.\n\ngene, metacell @ scaledlogcovered_fraction::Union{Float32, Float64} (guaranteed): The log of the relative fraction of covered genes, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"blocks.html#Metacells.Blocks.compute_blocks!","page":"Blocks","title":"Metacells.Blocks.compute_blocks!","text":"function compute_blocks!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```2.0e-5```,\n    min_significant_gene_UMIs::Integer = ```40```,\n    fold_confidence::AbstractFloat = ```0.9```,\n    max_block_span::Real = ```2```,\n    max_principal_components = ```40```,\n    min_blocks_in_neighborhood::Integer = ```4```,\n    min_metacells_in_neighborhood::Integer = ```20```,\n    min_covered_UMIs_in_neighborhood::Integer = ```2000000```,\n    cross_validation_parts::Integer = ```5```,\n    rng::AbstractRNG = default_rng(),\n    overwrite::Bool = ```false```,\n)::Nothing\n\nGroup the metacells into blocks where the metacells in each one are \"similar\" in all the skeleton genes. That is, each block is an approximation of a single cell state, assuming the skeleton genes adequately predict the rest of the genes. Then, group these blocks into overlapping small tight neighborhoods, and larger environments, such that each block's environment can be reasonably approximated using a local linear model, evaluated using cross-validation on the RMSE in the neighborhood at its core.\n\nFirst, we compute metacell-metacell distances based on the maximal fold factor between is_skeleton genes. The fold factor is log (base 2) of the gene expression using the gene_fraction_regularization. For computing this fold factor, we ignore \"insignificant\" genes whose total UMIs in the compared metacells isn't at least min_significant_gene_UMIs. We also we reduce the distance using the fold_confidence based on the number of UMIs used to estimate the expression in the metacells, Two metacells can only belong to the same block if the final fold factor is at most max_block_span in all the (significant, skeleton) genes.\n\nWe then compute block-block distances which are the mean distance between the metacells of the blocks. Using these distances, we define a tight neighborhood of each block containing at least min_blocks_in_neighborhood, min_metacells_in_neighborhood and min_covered_UMIs_in_neighborhood (note that the latter only counts UMIs of skeleton genes).\n\nHaving computed the neighborhoods, we expand them (using the same block-block distances) as long as computing a local linear model for the environment gives a better approximation of the metacells in the neighborhood. This local model starts with computing max_principal_components. These are assumed to over-fit the solution, so we use cross-validation (in cross_validation_parts) to pick a subset of these principal components, which hopefully approximates the true dimensionality of the local data.\n\nnote: Note\nThere is no attempt to reconcile the local model of neighboring blocks. In general the linear model computed here isn't very useful for interpreting the data as principal components for noisy high-dimensional data are pretty opaque.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\ngene @ is_skeleton::Bool (required): A mask of genes that are used to predict the values of the rest of the (covered) genes.\n\ngene @ divergence::Union{Float32, Float64} (required): Scale fold factors of each gene by multiplying with (1 - divergence) of the gene.\n\nMatrices\n\ngene, metacell @ total_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\ngene, metacell @ covered_fraction::Union{Float32, Float64} (required): The relative fraction of covered genes.\n\ngene, metacell @ scaledlogcovered_fraction::Union{Float32, Float64} (required): The log of the relative fraction of covered genes, scaled by divergence.\n\nOutputs\n\nAxes\n\nblock (guaranteed): Distinct groups of metacells with \"very close\" estimated cell state.\n\nprincipal_component (guaranteed): A principal component of a local linear program.\n\nVectors\n\nmetacell @ block::AbstractString (guaranteed): The unique block each metacell belongs to.\n\nblock @ nprincipalcomponents::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The number of used principal components of the local linear model for each block.\n\nblock @ linear_RMSE::Union{Float32, Float64} (guaranteed): The root mean squared error of predicting the covered genes using the linear model.\n\nblock @ linear_XRMSE::Union{Float32, Float64} (guaranteed): The cross-validated root mean squared error of predicting the covered genes using the linear model.\n\nMatrices\n\nblock, block @ isinneighborhood::Bool (guaranteed): For each block, the mask of nearby blocks in its immediate neighborhood.\n\nblock, block @ isinenvironment::Bool (guaranteed): For each block, the mask of nearby blocks in its linear environment.\n\nblock, principalcomponent @ isused::Bool (guaranteed): Whether each principal component is used by each block.\n\nblock, gene @ meanscaledlogcoveredfraction::Union{Float32, Float64} (guaranteed): The mean in the metacells of the block of the log of the relative fraction of covered genes, scaled by divergence.\n\nTensors\n\nblock; principalcomponent, gene @ skeletoncoefficient::Union{Float32, Float64} (guaranteed): The coefficient of each skeleton gene for computing a principle component.\n\nblock; principalcomponent, gene @ coveredcoefficient::Union{Float32, Float64} (guaranteed): The coefficient of each principal component for computing each covered (non-skeleton) gene.\n\n\n\n\n\n","category":"function"},{"location":"blocks.html#Metacells.Blocks.sharpen_metacells!","page":"Blocks","title":"Metacells.Blocks.sharpen_metacells!","text":"TODOX\n\n\n\n\n\n","category":"function"},{"location":"blocks.html#Index","page":"Blocks","title":"Index","text":"","category":"section"},{"location":"blocks.html","page":"Blocks","title":"Blocks","text":"Pages = [\"blocks.md\"]","category":"page"},{"location":"defaults.html#Defaults","page":"Defaults","title":"Defaults","text":"","category":"section"},{"location":"defaults.html","page":"Defaults","title":"Defaults","text":"Metacells.Defaults\nMetacells.Defaults.GENE_FRACTION_REGULARIZATION\nMetacells.Defaults.MIN_SIGNIFICANT_GENE_UMIS","category":"page"},{"location":"defaults.html#Metacells.Defaults","page":"Defaults","title":"Metacells.Defaults","text":"Default values for parameters.\n\n\n\n\n\n","category":"module"},{"location":"defaults.html#Metacells.Defaults.GENE_FRACTION_REGULARIZATION","page":"Defaults","title":"Metacells.Defaults.GENE_FRACTION_REGULARIZATION","text":"When computing log (base 2) of the fraction of the gene expression out of the total, we use this regularization factor by default top avoid zero values.\n\n\n\n\n\n","category":"constant"},{"location":"defaults.html#Metacells.Defaults.MIN_SIGNIFICANT_GENE_UMIS","page":"Defaults","title":"Metacells.Defaults.MIN_SIGNIFICANT_GENE_UMIS","text":"When comparing gene expression levels (e.g., when computing fold factors), we do not consider the result to be significant unless at least this number of UMIs were used to compute the compared value(s).\n\n\n\n\n\n","category":"constant"},{"location":"defaults.html#Index","page":"Defaults","title":"Index","text":"","category":"section"},{"location":"defaults.html","page":"Defaults","title":"Defaults","text":"Pages = [\"defaults.md\"]","category":"page"},{"location":"collect.html#Collect-Metacells","page":"Collect Metacells","title":"Collect Metacells","text":"","category":"section"},{"location":"collect.html","page":"Collect Metacells","title":"Collect Metacells","text":"Metacells.Collect\nMetacells.Collect.collect_metacells!","category":"page"},{"location":"collect.html#Metacells.Collect","page":"Collect Metacells","title":"Metacells.Collect","text":"Collect metacells.\n\n\n\n\n\n","category":"module"},{"location":"collect.html#Metacells.Collect.collect_metacells!","page":"Collect Metacells","title":"Metacells.Collect.collect_metacells!","text":"collect_metacells(\n    daf::DafWriter;\n    UMIs_regularization::AbstractFloat = ```0.0625```,\n    min_downsamples::Integer = ```750```,\n    min_downsamples_quantile::AbstractFloat = ```0.05```,\n    max_downsamples_quantile::AbstractFloat = ```0.5```,\n    rng::AbstractRNG = default_rng(),\n    overwrite::Bool = ```false```,\n)::Nothing\n\nGiven an assignment of cells to metacell, compute an estimation of the fraction of UMIs of each gene for each metacell.\n\nThe naive way to do this would be to just take the total UMIs of the gene out of the total UMIs of the metacell. However, this method has a weakness; a single strong cell with a \"very different\" fraction of the gene will dominate (that is, the method is sensitive to outliers).\n\nInstead, we take the geometric mean of the fractions of the gene in the cells. This however raises a few issues we need to deal with:\n\nGenes with zero UMIs are a problem; to combat this, we add a UMIs_regularization factor when computing the fractions, take the geomean, and subtract the regularization at the end (so all-zero genes will still get a zero overall fraction).\nWe want to give more weight to cells with more UMIs, so we use a scaled geomean. The weight we give to each cell is the log of the total number of UMIs in it.\nThe geomean fractions of all the genes in a metacell do not sum to one, so we scale them. This has the unfortunate side effect that the end result does not obey a nice relation to the linear fraction of the gene in each of the cells; in particular, the final result might be higher than all of these per-cell fractions (ouch).\n\nThis raises an important point about the whole \"fraction of UMIs of a gene in a cell\" concept, which is that it is highly dependent on the set of genes you pick to compute the fraction out of (that is, the denominator). This places restrictions on how you should use these fractions:\n\nYou can't just compare these fractions between two arbitrary data sets, as the denominators aren't the same. You must identify the set of common genes, and renormalize the fractions to sum to one in this subset, in both data sets. Only then can you meaningfully compare the results.\nEven if you compare two data sets with the same set of genes (or even two subsets of the same data set, such as two \"cell types\"), if a specific \"gene program\" has a very high total expression in only one of them, then all other genes will artificially appear to be lower.\nThis is why we recommend excluding ribosomal genes from the data sets; they can take up anything between almost none to over two thirds of the total UMIs, and this varies between \"cell types\". This means that if they are included in the denominator, the fractions of otherwise \"identical\" genes will appear to differ by a factor of up to 3X\nLuckily, most gene programs we deal with have a total expression of a few percent at most, so this effect is negligible. However if you identify a gene program with a total expression higher than, say, 10%, you should consider its effect on the rest of the genes.\n\nInputs\n\nAxes\n\ncell (required): Sequenced single cells.\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ncell @ total_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs of all the genes in each cell.\n\ncell @ metacell::AbstractString (required): The unique metacell each cell belongs to.\n\nMatrices\n\ngene, cell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of UMIs collected for each gene for each cell.\n\nOutputs\n\nVectors\n\nmetacell @ total_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of UMIs used to estimate the fraction of all the genes in each metacell.\n\nMatrices\n\ngene, metacell @ total_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\ngene, metacell @ fraction::Union{Float32, Float64} (guaranteed): The estimated fraction of the UMIs of each gene in each metacell.\n\n\n\n\n\n","category":"function"},{"location":"collect.html#Index","page":"Collect Metacells","title":"Index","text":"","category":"section"},{"location":"collect.html","page":"Collect Metacells","title":"Collect Metacells","text":"Pages = [\"collect.md\"]","category":"page"},{"location":"anndata_format.html#AnnData-Format","page":"AnnData Format","title":"AnnData Format","text":"","category":"section"},{"location":"anndata_format.html","page":"AnnData Format","title":"AnnData Format","text":"Metacells.AnnDataFormat\nMetacells.AnnDataFormat.import_cells_h5ad!\nMetacells.AnnDataFormat.import_metacells_h5ad!\nMetacells.AnnDataFormat.reconstruct_type_axis!\nMetacells.AnnDataFormat.CopyAnnData","category":"page"},{"location":"anndata_format.html#Metacells.AnnDataFormat","page":"AnnData Format","title":"Metacells.AnnDataFormat","text":"Import and export cells and metacells data from/to h5ad files. This allows moving data between the old Python/C++ based AnnData world and the brave new Julia based Daf world.\n\nThe expected flow is as follows:\n\nCreate a Daf repository for the raw input cells and import the raw cells h5ad into it using import_cells_h5ad!.\nAlternatively, import just the clean cells h5ad into it, but that would be leaving out some of the data so is not recommended.\nCreate another Daf repository for the metacells, chain it to the cells repository, and import the metacells into it using import_metacells_h5ad!. Give this the cells-with-metacells data h5ad - only the assignment of cells to metacells will be imported from it.\nIf you have any per-cell or per-gene computed data in the cells-with-metacells data h5ad (unlikely, as computed data typically goes into the metacells h5ad), import it into the chained (metacells) repository using import_cells_h5ad!.\nCreate a type axis in the chained metacells Daf repository using reconstruct_type_axis!.\n\n\n\n\n\n","category":"module"},{"location":"anndata_format.html#Metacells.AnnDataFormat.import_cells_h5ad!","page":"AnnData Format","title":"Metacells.AnnDataFormat.import_cells_h5ad!","text":"function import_cells_h5ad!(\n    daf::DafWriter;\n    cells_h5ad::AbstractString,\n    copy_data::Maybe{CopyAnnData} = ```nothing```,\n    bestify::Bool = ```true```,\n    min_sparse_saving_fraction::AbstractFloat = ```0.25```,\n    overwrite::Bool = ```false```,\n    insist::Bool = ```false```,\n)::Nothing\n\nImport an AnnData based cells dataset into a destination daf data set. Ideally you'd copy the full (raw) cells into an empty Daf repository. Then, you'd treat this repository as read-only, and copy the metacells data using import_metacells_h5ad! into a separate Daf repository chained with the read-only cells repository. This allows separate alternative metacells computations to share the read-only cells data.\n\nYou can copy an h5ad file containing just the clean cells on top of the raw cells data, to capture any data computed during or after computing the metacells. You may need to specify the copy_data to specify defaults for values of properties that exist only for clean cells and/or genes. Or, you can skip copying the raw data altogether, copying just the clean data into the base cells repository, though this is less recommended as you are needlessly discarding data that may prove to be useful later.\n\nThe bestify, min_sparse_saving_fraction, overwrite, and insist have their usual meaning from Daf's copying functions.\n\nWhen copying, we apply the following general rules:\n\nA something_gene per-gene property and/or something_cell per-cell property are renamed to is_something, (and given a default of false), because Daf (unlike AnnData) has no problem with properties with the same name for different axes.\nSimilarly {gene,cell}[s]_something_module and something_{gene,cell}[s]_module properties are renamed to something_module. We add 1 to the value and store the results in a UInt32; that is, in Daf, module indices are 1-based, and 0 is \"no module\".\nAny something_umis is renamed to something_UMIs, given a default of 0, and stored as a UInt32.\n\nAnd we make the following special exceptions:\n\nScalars:\n\nWe do not copy the __name__ scalar.\nAll other scalars are copied as-is.\n\nPer-cell-per-gene:\n\nThe X matrix is renamed to UMIs, and stored as a UInt32.\nNo other per-cell-per-gene matrix is copied by default.\n\nPer-gene:\n\nThe per-gene correction_factor is given the default value 0.\nThe fitted per-gene vector is renamed to is_fitted and given the default false.\nThe significant_inner_folds_count per-gene property is stored as a UInt32 and given the default 0.\nThe full_gene_index property is not copied. Either you import the full (raw) data or you don't.\nAll other vectors are copied as-is.\n\nPer-cell:\n\nThe full_cell_index property is not copied. Either you import the full (raw) data or you don't.\nThe metacell, metacell_name, metacell_level, most_similar and most_similar_name per-cell properties are not copied. To import these, use import_metacells_h5ad!.\nAll other vectors are copied as-is.\n\nnote: Note\nIt is common to manually call reconstruct_axis! on the result to create additional axes (e.g., if the cells were collected from a set of batches and some properties are actually per-batch).\n\n\n\n\n\n","category":"function"},{"location":"anndata_format.html#Metacells.AnnDataFormat.import_metacells_h5ad!","page":"AnnData Format","title":"Metacells.AnnDataFormat.import_metacells_h5ad!","text":"function import_metacells_h5ad!(\n    daf::DafWriter;\n    cells_h5ad::AbstractString,\n    metacells_h5ad::AbstractString,\n    copy_data::Maybe{CopyAnnData} = ```nothing```,\n    bestify::Bool = ```true```,\n    min_sparse_saving_fraction::AbstractFloat = ```0.25```,\n    overwrite::Bool = ```false```,\n    insist::Bool = ```false```,\n)::Nothing\n\nImport an AnnData based metacells dataset into a destination daf data set. It is expected that you have first imported the per-cell data. Ideally you'd create a new empty repository for the metacells data and chained it on top of the per-cell repository, which you'd keep read-only to allow sharing it when you (inevitably) compute different metacells for it.\n\nThis behaves similarly to import_cells_h5ad!, specifically the generic rules (except that we copy per-metacell properties and not per-cell properties so the rules are adjusted accordingly), and we make the following special exceptions:\n\nPer-metacell-per-gene:\n\nThe X matrix is renamed to fraction and always stored as Float32.\nThe corrected_fraction matrix is always stored as Float32.\nThe essential matrix is renamed to is_essential.\nThe essential, fitted, and misfit matrices are renamed to is_essential, is_fitted and is_misfit, respectively.\nThe inner_fold, inner_stdev_log, projected_fold, projected_fraction matrices are always stored as Float32.\nThe total_umis matrix is renamed to total_UMIs and always stored as UInt32.\nThe zeros matrix is always stored as UInt32.\nAll other matrices are copied as-is.\n\nScalars and Per-gene:\n\nSame as in import_cells_h5ad!\n\nPer-cell:\n\nThe only properties we copy per cell are metacell_name (renamed to metacell with a default of the empty string), and similarly most_similar_name (renamed to most_similar.metacell, same default). That's the only reason we have a cells_h5ad parameter. You should therefore pass here the cells-with-metacells and not the clean cells h5ad.\n\nPer-metacell:\n\nThe metacells_level property is renamed to level.\nThe similar property is renamed to is_similar.\nThe type property is copied. If \"the\" type property of the metacells is different, use copy_data to rename it to type to match the Daf naming convention.\nAll other vectors are copied as-is.\n\nPer-metacell-per-metacell:\n\nThe obs_outgoing_weights matrix is renamed to outgoing_weights and always stored as Float32.\nAll other matrices are copied as-is.\n\nnote: Note\nIt is common to manually call reconstruct_type! on the result to create a type axis.\n\n\n\n\n\n","category":"function"},{"location":"anndata_format.html#Metacells.AnnDataFormat.reconstruct_type_axis!","page":"AnnData Format","title":"Metacells.AnnDataFormat.reconstruct_type_axis!","text":"reconstruct_type!(\n    daf::DafWriter,\n    base_axis::AbstractString = ```\"metacell\"```,\n    type_property::AbstractString = ```\"type\"```,\n    type_axis::AbstractString = ```\"type\"```,\n    empty_type::Maybe{AbstractString} = ```nothing```,\n    type_colors_csv::Maybe{AbstractString} = ```nothing```,\n    implicit_properties::Maybe{AbstractSet{<:AbstractString}} = ```nothing```,\n    skipped_properties::Maybe{AbstractSet{<:AbstractString}} = ```2 x Str (Set)```,\n    properties_defaults::Maybe{Dict} = ```nothing```,\n)::Nothing\n\nCreate a type axis after importing data containing type annotations. By default this will look for a type per metacell, but if you have type annotation per cell (which is not simply the type of the metacell they belong to), you can also use this for the cells.\n\nBy default this assumes that you have imported \"the\" type annotation to a property called \"type\", and that you would like the new type axis to be called \"type\" as well. If you want to import secondary types (or per-cell types), change these via the type_property and type_axis parameters.\n\nIf the type is equal to empty_type it is replaced with the empty string to match the Daf conventions for \"no value\" for string properties. Any set of per-gene properties named something_gene_of_type is converted to a per-gene-per-type matrix called is_something (with a default of false).\n\nOtherwise, this is mostly just a wrapper for reconstruct_axis!. It can be further enhanced by specifying a type_colors_csv file mapping type names to colors. This should be a comma or tab separated file containing at least two columns, one named \"color\" and one with the same name as the type_property. If this CSV file contains types that aren't actually used in the data, you will have to specify a default value for any other per-type property in properties_defaults.\n\nnote: Note\nMost metacells data has type annotations and colors associated with types, so it is highly recommended you invoke this to capture these into the Daf repository. This will enable all types (:-) of downstream processing, coloring graphs, etc.\n\n\n\n\n\n","category":"function"},{"location":"anndata_format.html#Metacells.AnnDataFormat.CopyAnnData","page":"AnnData Format","title":"Metacells.AnnDataFormat.CopyAnnData","text":"Specify how to copy data from AnnData to Daf. The key is simply a vector or matrix name (ignoring axes), and the value is either nothing to ignore the data, or a tuple with the name of the destination Daf property and an optional value to use for missing entries (raw-only cells and/or genes).\n\n\n\n\n\n","category":"type"},{"location":"anndata_format.html#Index","page":"AnnData Format","title":"Index","text":"","category":"section"},{"location":"anndata_format.html","page":"AnnData Format","title":"AnnData Format","text":"Pages = [\"anndata_format.md\"]","category":"page"},{"location":"gmara.html#Gmara","page":"Gmara","title":"Gmara","text":"","category":"section"},{"location":"gmara.html","page":"Gmara","title":"Gmara","text":"Metacells.Gmara","category":"page"},{"location":"gmara.html#Metacells.Gmara","page":"Gmara","title":"Metacells.Gmara","text":"Access gene names lists from Gmara.\n\nnote: Note\nAll the functions here are thread-safe and can also be invoked from multiple parallel processes using the same CACHE_DIR. This directory can even be shared between multiple users as long as they have read-write permissions to the shared directory. This should even work on NFS mounted volumes shared between multiple servers.\n\n\n\n\n\n","category":"module"},{"location":"gmara.html#Configuration","page":"Gmara","title":"Configuration","text":"","category":"section"},{"location":"gmara.html","page":"Gmara","title":"Gmara","text":"Metacells.Gmara.CACHE_DIR\nMetacells.Gmara.TIMEOUT","category":"page"},{"location":"gmara.html#Metacells.Gmara.CACHE_DIR","page":"Gmara","title":"Metacells.Gmara.CACHE_DIR","text":"The default ($HOME/.cache/gmara) location of the cache of downloaded Gmara data files.\n\nYou can override this by setting the METACELLS_GMARA_CACHE_DIR environment variable, or by passing an explicit cache_dir parameter to the functions.\n\nThe top-level under this is the version indicator, where main is always the latest and greatest version. Under each version we store the files in the same path as in github, with a .gz suffix for the compressed raw data, .jl_set.gz for serialized Julia set objects, and .lock for temporary lock files for coordinating between parallel processes.\n\n\n\n\n\n","category":"constant"},{"location":"gmara.html#Metacells.Gmara.TIMEOUT","page":"Gmara","title":"Metacells.Gmara.TIMEOUT","text":"The default timeout in seconds (10) for waiting for a lock file in the Gmara cache. If not positive, will wait forever. If a process crashes very badly then a lock file may be left behind and may need to be removed by hand to allow access for the data.\n\nYou can override this by setting the METACELLS_GMARA_TIMEOUT environment variable, or by passing an explicit timeout parameter to the functions.\n\n\n\n\n\n","category":"constant"},{"location":"gmara.html#Functions","page":"Gmara","title":"Functions","text":"","category":"section"},{"location":"gmara.html","page":"Gmara","title":"Gmara","text":"Metacells.Gmara.normalize_gene_name\nMetacells.Gmara.gmara_genes\nMetacells.Gmara.set_gmara_genes_mask!\nMetacells.Gmara.empty_gmara_cache!","category":"page"},{"location":"gmara.html#Metacells.Gmara.normalize_gene_name","page":"Gmara","title":"Metacells.Gmara.normalize_gene_name","text":"normalize_gene_name(name::AbstractString; namespace::AbstractString)::AbstractString\n\nNormalize the a gene name in some namespace. In most namespaces, this means removing the .[0-9] version suffix from the name, and converting the name to upper case. To lookup a name in a list or a namespace, you need to normalize the query gene name accordingly. The UCSC namespace is an exception in that it is all-lower-case and the .[0-9] suffix seems to be an inherent part of the identifier.\n\n\n\n\n\n","category":"function"},{"location":"gmara.html#Metacells.Gmara.gmara_genes","page":"Gmara","title":"Metacells.Gmara.gmara_genes","text":"gmara_genes(;\n    species::AbstractString,\n    namespace::AbstractString,\n    [list::Maybe{AbstractString} = nothing,\n    version::AbstractString = \"main\"\n    cache_dir = CACHE_DIR,\n    timeout::Real = TIMEOUT],\n)::AbstractSet{<:AbstractString}\n\nReturn the set of names of a version of a list in a namespace of genes of some species. This returns all the names that are (probably) in the list; it a name isn't in the result, it is almost certain it does not belong in the list. As usual in Gmara, this includes everything that may be used as name, e.g. for Ensembl it includes genes, transcripts and proteins; for Symbol it includes approved and alises; etc. If the list is nothing, this just returns the set of known gene names in the namespace.\n\n\n\n\n\n","category":"function"},{"location":"gmara.html#Metacells.Gmara.set_gmara_genes_mask!","page":"Gmara","title":"Metacells.Gmara.set_gmara_genes_mask!","text":"set_gmara_genes_mask!(\n    daf::DafWriter;\n    species::AbstractString,\n    namespace::AbstractString,\n    [list::Maybe{AbstractString} = nothing,\n    gene_names::AbstractString = \"name\",\n    property::Maybe{AbstractString} = nothing,\n    overwrite::Bool = false,\n    cache_dir = CACHE_DIR,\n    timeout::Real = TIMEOUT],\n)::Nothing\n\nSet a gene property mask in daf based on some version of a Gmara list of some namespace for some species. We match the gene_names (by default, just the unique names in the gene axis) with the list names and set the result mask as a per-gene property (by default, is_list). If list is nothing, this just marks the gene names that exist in the namespace. If overwrite, this will overwrite an existing property of the.array same name.\n\n\n\n\n\n","category":"function"},{"location":"gmara.html#Metacells.Gmara.empty_gmara_cache!","page":"Gmara","title":"Metacells.Gmara.empty_gmara_cache!","text":"empty_gmara_cache!()::Nothing\n\nAll requests are cached in-memory. This makes repeated requests cheap. This consumes some (modest amount of) memory; also, if the data in the server has been updated (which rarely happens), you will keep getting the old result. This function releases all the memory and forces all subsequent requests to query the server. In the common case the server tells us our disk cache data is up to date, we don't re-download it).\n\n\n\n\n\n","category":"function"},{"location":"gmara.html#Index","page":"Gmara","title":"Index","text":"","category":"section"},{"location":"gmara.html","page":"Gmara","title":"Gmara","text":"Pages = [\"gmara.md\"]","category":"page"},{"location":"index.html#Metacells","page":"Metacells","title":"Metacells","text":"","category":"section"},{"location":"index.html","page":"Metacells","title":"Metacells","text":"Metacells.Metacells","category":"page"},{"location":"index.html#Metacells.Metacells","page":"Metacells","title":"Metacells.Metacells","text":"The Metacells.jl package provides computational services for the metacells package, using Daf to hold the data. In the future, we'll ideally migrate all of the metacellspackage computations to this package, converting the Python package to a thin wrapper, and provide a similar thin R wrapper to provide metacell analysis from R as well. For now,Metacells.jlonly provides a subset of the features of the Pythonmetacellspackage, which requires users to convert data fromAnnData(for the old features) to Daf (to the new features).\n\n\n\n\n\n","category":"module"},{"location":"index.html#Index","page":"Metacells","title":"Index","text":"","category":"section"},{"location":"index.html","page":"Metacells","title":"Metacells","text":"","category":"page"},{"location":"contracts.html#Contracts","page":"Contracts","title":"Contracts","text":"","category":"section"},{"location":"contracts.html","page":"Contracts","title":"Contracts","text":"Metacells.Contracts","category":"page"},{"location":"contracts.html#Metacells.Contracts","page":"Contracts","title":"Metacells.Contracts","text":"Functions for defining a Contract for a metacells Daf data set @computation. This also serves as a vocabulary describing the data we keep when doing metacells based analysis, which is a solid basis for understanding what is going on. As Fred Brooks said: \"Show me your flowcharts and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won’t usually need your flowcharts; they’ll be obvious.\".\n\nIn the descriptions below, \"fold factor\" refers to the log base 2 of the ratio between expression levels. For fold factors between gene RNA expression levels (fractions), we typically use a regularization factor of 1e-5 to avoid division by zero.\n\n\n\n\n\n","category":"module"},{"location":"contracts.html#Axes","page":"Contracts","title":"Axes","text":"","category":"section"},{"location":"contracts.html","page":"Contracts","title":"Contracts","text":"Metacells.Contracts.gene_axis\nMetacells.Contracts.cell_axis\nMetacells.Contracts.metacell_axis\nMetacells.Contracts.old_metacell_axis\nMetacells.Contracts.new_metacell_axis\nMetacells.Contracts.type_axis\nMetacells.Contracts.block_axis\nMetacells.Contracts.principal_component_axis","category":"page"},{"location":"contracts.html#Metacells.Contracts.gene_axis","page":"Contracts","title":"Metacells.Contracts.gene_axis","text":"gene_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of sequenced genes. By convention we use gene symbols as the namespace of the genes, but this may be different depending on the data set.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_axis","page":"Contracts","title":"Metacells.Contracts.cell_axis","text":"cell_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of sequenced single cells. There's no convention for cell names, as long as they are unique. Typically some sort of barcode is used, possibly combined with a batch and/or plate and/or experiment identification. In the latter case it is recommended that batch and/or plate and/or experiment would also be created as explicit axes, to allow associating metadata with them instead of repeating it for each cell.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_axis","page":"Contracts","title":"Metacells.Contracts.metacell_axis","text":"metacell_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of metacells, which are minimal-sized groups of cells for robust point estimates. Each metacell is considered to be a robustly estimated point in the multi-dimensional manifold of cell states. Metacells may be very similar or very different from each other depending on the data set and the manifold region.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.old_metacell_axis","page":"Contracts","title":"Metacells.Contracts.old_metacell_axis","text":"old_metacell_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nOld metacells when computing new ones. This is the same as the regular metacells axis, but renamed to avoid confusion when computing a new set of metacells for some data based on the old metacells.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.new_metacell_axis","page":"Contracts","title":"Metacells.Contracts.new_metacell_axis","text":"new_metacell_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nNew metacells when improving old ones. This is the same as the regular metacells axis, but renamed to avoid confusion when computing a new set of metacells for some data based on the old metacells.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.type_axis","page":"Contracts","title":"Metacells.Contracts.type_axis","text":"type_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of types, which are distinct named biological cell states. Types are convenient labels manually assigned to large groups of cells, metacells, blocks, neighborhoods, etc. The resolution of the type labels depends on the data set and the type of analysis. In particular, types are not typically associated with a specific biological cell state, but rather with a set of related biological cell states (possibly along a gradient of such states).\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_axis","page":"Contracts","title":"Metacells.Contracts.block_axis","text":"block_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of blocks, which are distinct groups of metacells with \"very close\" estimated cell state. The metacells in each block all have very close estimates of the skeleton gene expressions (maximal fold factor up to some maximal span).\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.principal_component_axis","page":"Contracts","title":"Metacells.Contracts.principal_component_axis","text":"principal_component_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of principal components of local linear programs.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Vectors","page":"Contracts","title":"Vectors","text":"","category":"section"},{"location":"contracts.html","page":"Contracts","title":"Contracts","text":"Metacells.Contracts.gene_is_excluded_vector\nMetacells.Contracts.gene_is_lateral_vector\nMetacells.Contracts.gene_is_marker_vector\nMetacells.Contracts.gene_marker_rank_vector\nMetacells.Contracts.gene_is_uncorrelated_vector\nMetacells.Contracts.gene_is_covered_vector\nMetacells.Contracts.gene_is_forbidden_vector\nMetacells.Contracts.gene_is_skeleton_vector\nMetacells.Contracts.gene_divergence_vector\nMetacells.Contracts.cell_is_excluded_vector\nMetacells.Contracts.cell_total_UMIs_vector\nMetacells.Contracts.metacell_total_UMIs_vector\nMetacells.Contracts.metacell_covered_UMIs_vector\nMetacells.Contracts.metacell_block_vector\nMetacells.Contracts.metacell_type_vector\nMetacells.Contracts.new_metacell_block_vector\nMetacells.Contracts.old_metacell_block_vector\nMetacells.Contracts.type_color_vector\nMetacells.Contracts.block_n_principal_components_vector\nMetacells.Contracts.block_linear_RMSE_vector\nMetacells.Contracts.block_linear_XRMSE_vector","category":"page"},{"location":"contracts.html#Metacells.Contracts.gene_is_excluded_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_excluded_vector","text":"gene_is_excluded_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that are excluded from consideration. These genes are completely unrelated to the biological behaviors of interest. Not only that, they have strong and variable expression levels; enough to have an global impact on the expression level of the rest of the genes - for example, mitochondrial genes. Such genes make it difficult to estimate the relative expression level of genes between different cell states. Therefore, such genes aren't even counted in the total UMIs of each cell.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_lateral_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_lateral_vector","text":"gene_is_lateral_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that are lateral to the biological behaviors of interest. These genes may satisfy all criteria for being in a group of cooperating genes, but the biological behavior they participate in isn't relevant to the behaviors of interest - for example, genes related to cell cycle or stress. Such genes make it harder to focus on the biological behaviors of interest. They are therefore masked out during the analysis.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_marker_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_marker_vector","text":"gene_is_marker_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that distinguish between cell states. These genes have a significant expression level at some cell state, as well as a significant range of expression across all cell states, so can be used to distinguish between cell states. Non-marker genes are by definition not useful for such analysis, but marker genes aren't necessarily useful due to other considerations.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_marker_rank_vector","page":"Contracts","title":"Metacells.Contracts.gene_marker_rank_vector","text":"gene_marker_rank_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe relative ranks of the marker genes. The more the gene distinguishes between different cell states, the better (lower) rank it has. That is, 1 is for the \"most\" marker gene. Non-marker genes are given an extremely high rank (that maximal the data type allows).\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_uncorrelated_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_uncorrelated_vector","text":"gene_is_uncorrelated_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that are not correlated with other gene(s). We typically search for groups of genes that act together. Genes that have no correlation with other genes aren't useful for this sort of analysis, even if they are marker genes.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_covered_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_covered_vector","text":"gene_is_covered_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that are covered by the local linear program. When we approximate the manifold using these local linear programs, we only model these genes, ignoring the rest. This allows the approximation to be unaffected by \"irrelevant\" genes.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_forbidden_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_forbidden_vector","text":"gene_is_forbidden_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that are forbidden from being used as skeleton factors. When searching for a set of genes that predict the expression of the rest of the genes, we do not consider the forbidden genes.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_skeleton_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_skeleton_vector","text":"gene_is_skeleton_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that are used to predict the values of the rest of the (covered) genes. The local programs that we use to approximate the manifold are linear combinations of the skeleton genes. A linear combination of a small set of (different) such programs is used to predict the rest of the genes.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_divergence_vector","page":"Contracts","title":"Metacells.Contracts.gene_divergence_vector","text":"gene_divergence_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nFor each gene, we scale fold factors of each gene by multiplying with (1 - divergence) of the gene. In particular this is used when considering the distance between gene expressions. Therefore genes with a non-zero divergence will require a higher fold factor\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_is_excluded_vector","page":"Contracts","title":"Metacells.Contracts.cell_is_excluded_vector","text":"cell_is_excluded_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of cells that are excluded from consideration. This can be due to any number of reasons - doublets, too low a number of UMIs, to high a percentage of excluded gene UMIs, etc.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_total_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.cell_total_UMIs_vector","text":"cell_total_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of all the genes in each cell. This doesn't include the UMIs of genes excluded for any reason.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_total_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.metacell_total_UMIs_vector","text":"metacell_total_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs used to estimate the fraction of all the genes in each metacell. This is used to estimate the robustness of the gene fraction estimates.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_covered_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.metacell_covered_UMIs_vector","text":"metacell_covered_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of the covered genes in each metacell. This is used to estimate the robustness of the gene fraction estimates.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_block_vector","page":"Contracts","title":"Metacells.Contracts.metacell_block_vector","text":"metacell_block_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe unique block each metacell belongs to. All the metacells in the same block are assumed to be \"very close\" to each other, so much so that it is excusable to treat them as \"the same\" cell state.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_type_vector","page":"Contracts","title":"Metacells.Contracts.metacell_type_vector","text":"metacell_type_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe type each metacell belongs to.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.new_metacell_block_vector","page":"Contracts","title":"Metacells.Contracts.new_metacell_block_vector","text":"new_metacell_block_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe unique block each new metacell belongs to. This just uses the renamed old metacells axis when computing a new set of metacells for some data based on the old metacells.\n\nnote: Note\nThe old and new metacells are associated with the same set of blocks, at least initially. At some point you would compute brand new blocks for the new metacells, but as these are not based on the old blocks, there's no need to access both sets of blocks at the same time so no need for \"old blocks\" and \"new blocks\".\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.old_metacell_block_vector","page":"Contracts","title":"Metacells.Contracts.old_metacell_block_vector","text":"old_metacell_block_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe unique block each old metacell belongs to. This just uses the renamed old metacells axis when computing a new set of metacells for some data based on the old metacells.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.type_color_vector","page":"Contracts","title":"Metacells.Contracts.type_color_vector","text":"type_color_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA unique color for each type for graphs.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_n_principal_components_vector","page":"Contracts","title":"Metacells.Contracts.block_n_principal_components_vector","text":"block_n_principal_components_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe number of used principal components of the local linear model for each block. Since Daf can only deal with fixed-sized axes, we create a \"too large\" principal components axis. Each block actually uses a smaller (different) number of principal components that hopefully reflects the actual dimensionality of the manifold at that point. The coefficients of the rest of the principal components are set to zero.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_linear_RMSE_vector","page":"Contracts","title":"Metacells.Contracts.block_linear_RMSE_vector","text":"block_linear_RMSE_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe root mean squared error of predicting the covered genes using the local linear models. This model computes principal components from the skeleton genes and then uses these components to predict the values of all covered genes.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_linear_XRMSE_vector","page":"Contracts","title":"Metacells.Contracts.block_linear_XRMSE_vector","text":"block_linear_XRMSE_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe cross-validated root mean squared error of predicting the covered genes using the linear model. This is similar to the RMSE, but is computed using cross-validation (training a linear model on a subset of the local metacells and evaluating it on the rest). This will be higher than the RMSE; the difference is an indicator of the \"overfitting\" of the linear model, which should be low relative to the total RMSE.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Matrices","page":"Contracts","title":"Matrices","text":"","category":"section"},{"location":"contracts.html","page":"Contracts","title":"Contracts","text":"Metacells.Contracts.cell_gene_UMIs_matrix\nMetacells.Contracts.cell_metacell_vector\nMetacells.Contracts.cell_new_metacell_vector\nMetacells.Contracts.cell_old_metacell_vector\nMetacells.Contracts.metacell_gene_fraction_matrix\nMetacells.Contracts.metacell_gene_total_UMIs_matrix\nMetacells.Contracts.metacell_gene_covered_fraction_matrix\nMetacells.Contracts.metacell_gene_scaled_log_covered_fraction_matrix\nMetacells.Contracts.old_metacell_gene_scaled_log_covered_fraction_matrix\nMetacells.Contracts.block_block_is_in_neighborhood_matrix\nMetacells.Contracts.block_block_is_in_environment_matrix\nMetacells.Contracts.block_gene_fraction_matrix\nMetacells.Contracts.block_gene_total_UMIs_matrix\nMetacells.Contracts.block_gene_mean_scaled_log_covered_fraction_matrix\nMetacells.Contracts.block_principal_component_is_used_matrix\nMetacells.Contracts.block_principal_component_gene_covered_coefficient_tensor\nMetacells.Contracts.block_principal_component_gene_skeleton_coefficient_tensor","category":"page"},{"location":"contracts.html#Metacells.Contracts.cell_gene_UMIs_matrix","page":"Contracts","title":"Metacells.Contracts.cell_gene_UMIs_matrix","text":"cell_gene_UMIs_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe number of UMIs collected for each gene for each cell. This is the \"ground truth\" everything else is built on. The total number of UMIs per cell differs (sometimes wildly) based on the scRNA-seq technology and protocol.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_metacell_vector","page":"Contracts","title":"Metacells.Contracts.cell_metacell_vector","text":"cell_metacell_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe unique metacell each cell belongs to. All the cells in the same metacell are assumed to have \"the same\" (relevant) biological state. This is the empty string if the cell does not belong to any metacell (is excluded or outlier).\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_new_metacell_vector","page":"Contracts","title":"Metacells.Contracts.cell_new_metacell_vector","text":"cell_new_metacell_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe unique new metacell each cell belongs to. This just uses the renamed new metacells axis when computing a new set of metacells for some data based on the old metacells.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_old_metacell_vector","page":"Contracts","title":"Metacells.Contracts.cell_old_metacell_vector","text":"cell_old_metacell_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe unique old metacell each cell belongs to. This just uses the renamed old metacells axis when computing a new set of metacells for some data based on the old metacells.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_fraction_matrix","text":"metacell_gene_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe estimated fraction of the UMIs of each gene in each metacell. We assume that each metacell is a sample of the manifold, representing a real biological state, regardless to its distance to other metacells (subject to cleaning up batch effects, purging doublets, and compensating for any other technical artifacts).\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_total_UMIs_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_total_UMIs_matrix","text":"metacell_gene_total_UMIs_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe total number of UMIs used to estimate the fraction of each gene in each metacell. This is used to estimate the robustness of the estimate. When computing fold factors, we require the total number of UMIs (from both compared estimates) to be some minimum, and possibly adjust the fold factor according to some confidence level (assuming a multinomial sampling distribution).\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_covered_fraction_matrix","text":"metacell_gene_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe relative fraction of covered genes. This ensures the sum of the fractions of the covered genes is one in each metacell, to ignore the impact of any residual uncovered gene programs.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_scaled_log_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_scaled_log_covered_fraction_matrix","text":"metacell_gene_scaled_log_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log of the relative fraction of covered genes, scaled by divergence. This computes the log base 2 of the metacell_gene_covered_fraction_matrix, with some regularization, and then scales the result using the gene_divergence_vector so that the range of expression of \"wild\" genes is reduced. The end result is what we actually try to fit with local linear programs.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.old_metacell_gene_scaled_log_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.old_metacell_gene_scaled_log_covered_fraction_matrix","text":"old_metacell_gene_scaled_log_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log of the relative fraction of covered genes, scaled by divergence. This just uses the renamed old metacells axis when computing a new set of metacells for some data based on the old metacells.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_block_is_in_neighborhood_matrix","page":"Contracts","title":"Metacells.Contracts.block_block_is_in_neighborhood_matrix","text":"block_block_is_in_neighborhood_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nFor each block, the mask of nearby blocks in its immediate neighborhood. The neighborhood consists of a small number of very close blocks, which we use as the basis for evaluating linear approximations (of the log of the expression of the genes).\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_block_is_in_environment_matrix","page":"Contracts","title":"Metacells.Contracts.block_block_is_in_environment_matrix","text":"block_block_is_in_environment_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nFor each block, the mask of nearby blocks in its linear environment. We expect the covered genes in the metacells in the blocks of the environment to reasonably fit a local linear model (of the log of the expression).\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_fraction_matrix","text":"block_gene_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe estimated fraction of the UMIs of each gene in each block. This assumes the metacells in each block are samples of the \"same\" biological state, based on the fact that all these metacells have very similar expression levels for all the global predictive transcription factors.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_total_UMIs_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_total_UMIs_matrix","text":"block_gene_total_UMIs_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe total number of UMIs used to estimate the fraction of each gene in each block. This is used to estimate the robustness of the estimate. When computing fold factors, we require the total number of UMIs (from both compared estimates) to be some minimum, and possibly adjust the fold factor according to some confidence level (assuming a multinomial sampling distribution).\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_mean_scaled_log_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_mean_scaled_log_covered_fraction_matrix","text":"block_gene_mean_scaled_log_covered_fraction_matrix(\n    expectation::ContractExpectation,\n)::Pair{VectorKey, DataSpecification}\n\nThe mean in the metacells of the block of the log of the relative fraction of covered genes, scaled by divergence. This is used by the linear model; specifically, the coefficients are applied to the difference from this mean, and the results are added back to this mean. This is zero for uncovered genes.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_principal_component_is_used_matrix","page":"Contracts","title":"Metacells.Contracts.block_principal_component_is_used_matrix","text":"block_principal_component_is_used_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nWhether each principal component is used by each block. This mask is true for the first used principal components of each block and false for the rest. It is useful for constructing Daf queries that only return coefficients for the used principal components for a specific block (e.g., gene & is_skeleton / principal_component & is_used ; block = $(block_name) : $(block_name)_skeleton_coefficient).\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_principal_component_gene_covered_coefficient_tensor","page":"Contracts","title":"Metacells.Contracts.block_principal_component_gene_covered_coefficient_tensor","text":"block_principal_component_gene_covered_coefficient_tensor(\n    expectation::ContractExpectation\n)::Pair{TensorKey, DataSpecification}\n\nThe coefficient of each principal component for computing each covered gene. This is zero for uncovered genes. Combined with the skeleton genes coefficients this gives a local linear model for estimating all the covered genes (including the skeleton genes).\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_principal_component_gene_skeleton_coefficient_tensor","page":"Contracts","title":"Metacells.Contracts.block_principal_component_gene_skeleton_coefficient_tensor","text":"block_principal_component_gene_skeleton_coefficient_tensor(\n    expectation::ContractExpectation\n)::Pair{TensorKey, DataSpecification}\n\nThe coefficient of each skeleton gene for computing a principle component. This is zero for non-skeleton genes. The coefficients can be either positive or negative. Combined with the covered genes coefficients this gives a local linear model for estimating all the covered genes.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Index","page":"Contracts","title":"Index","text":"","category":"section"},{"location":"contracts.html","page":"Contracts","title":"Contracts","text":"Pages = [\"contracts.md\"]","category":"page"}]
}
