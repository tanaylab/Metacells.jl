var documenterSearchIndex = {"docs":
[{"location":"defaults.html#Defaults","page":"Defaults","title":"Defaults","text":"","category":"section"},{"location":"defaults.html#Metacells.Defaults","page":"Defaults","title":"Metacells.Defaults","text":"Default values for parameters.\n\n\n\n\n\n","category":"module"},{"location":"defaults.html#Metacells.Defaults.GENE_FRACTION_REGULARIZATION","page":"Defaults","title":"Metacells.Defaults.GENE_FRACTION_REGULARIZATION","text":"When computing log (base 2) of the fraction of the gene expression out of the total, we use this regularization factor by default top avoid zero values.\n\n\n\n\n\n","category":"constant"},{"location":"defaults.html#Metacells.Defaults.MIN_SIGNIFICANT_GENE_UMIS","page":"Defaults","title":"Metacells.Defaults.MIN_SIGNIFICANT_GENE_UMIS","text":"When comparing gene expression levels (e.g., when computing fold factors), we do not consider the result to be significant unless at least this number of UMIs were used to compute the compared value(s).\n\n\n\n\n\n","category":"constant"},{"location":"defaults.html#Index","page":"Defaults","title":"Index","text":"","category":"section"},{"location":"defaults.html","page":"Defaults","title":"Defaults","text":"Pages = [\"defaults.md\"]","category":"page"},{"location":"compute_blocks.html#Compute-Blocks","page":"Compute Blocks","title":"Compute Blocks","text":"","category":"section"},{"location":"compute_blocks.html#Metacells.ComputeBlocks","page":"Compute Blocks","title":"Metacells.ComputeBlocks","text":"Group \"very close\" metacells into disjoint blocks, and blocks into overlapping vicinities, for constructing a local linear approximation to the manifold.\n\n\n\n\n\n","category":"module"},{"location":"compute_blocks.html#Metacells.ComputeBlocks.compute_blocks!","page":"Compute Blocks","title":"Metacells.ComputeBlocks.compute_blocks!","text":"function compute_blocks!(\n    daf::DafWriter;\n    max_block_span::Real = ```2```,\n    num_blocks::Integer = ```nothing```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nGroup the metacells into blocks where the metacells in each one are \"similar\" in all the skeleton genes. That is, each block is an approximation of a single cell state, assuming the skeleton genes adequately predict the rest of the genes.\n\nTODOX\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nMatrices\n\nmetacell, metacell @ maxskeletonfold_distance::Union{Float32, Float64} (optional): The maximal significant fold factor between the covered fraction of skeleton genes between the metacells.\n\nmetacell, metacell @ euclideanskeletondistance::Union{Float32, Float64} (optional): The Euclidean distance between the log of the covered fraction of the skeleton genes between the metacells.\n\nOutputs\n\nAxes\n\nblock (guaranteed): Distinct groups of metacells with \"very close\" cell state.\n\nVectors\n\nmetacell @ block::AbstractString (guaranteed): The unique block each metacell belongs to.\n\n\n\n\n\n","category":"function"},{"location":"compute_blocks.html#Metacells.ComputeBlocks.compute_blocks_is_in_neighborhood!","page":"Compute Blocks","title":"Metacells.ComputeBlocks.compute_blocks_is_in_neighborhood!","text":"function compute_blocks_is_in_neighborhood!(\n    daf::DafWriter;\n    min_blocks_in_neighborhood::Integer = ```5```,\n    min_metacells_in_neighborhood::Integer = ```20```,\n    min_covered_UMIs_in_neighborhood::Integer = ```2000000```,\n    rng::AbstractRNG = default_rng(),\n    overwrite::Bool = ```false```,\n)::Nothing\n\nTODOX\n\nGroup the blocks into overlapping small tight neighborhoods, and larger environments, such that each block's environment can be reasonably approximated using a local linear model, evaluated using cross-validation on the RMSE in the neighborhood at its core.\n\nUsing the block-block distances, we define a tight neighborhood of each block containing at least min_blocks_in_neighborhood, min_metacells_in_neighborhood and min_covered_UMIs_in_neighborhood (note that the latter only counts UMIs of skeleton genes).\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nVectors\n\nblock @ covered_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of the all covered genes in each block.\n\nblock @ n_metacells::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of metacells in each block.\n\nMatrices\n\nblock, block @ maxskeletonfold_distance::Union{Float32, Float64} (optional): The maximal significant skeleton genes covered fractions fold factor between metacells of the blocks.\n\nblock, block @ meaneuclideanskeleton_distance::Union{Float32, Float64} (optional): The mean Euclidean skeleton genes covered fractions distance between the metacells of the blocks.\n\nOutputs\n\nMatrices\n\nblock, block @ isinneighborhood::Bool (guaranteed): For each block, the (column) mask of nearby blocks in its immediate neighborhood.\n\n\n\n\n\n","category":"function"},{"location":"compute_blocks.html#Metacells.ComputeBlocks.compute_blocks_is_in_environment!","page":"Compute Blocks","title":"Metacells.ComputeBlocks.compute_blocks_is_in_environment!","text":"function compute_blocks_is_in_environment!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nTODOX\n\nGroup the blocks into overlapping small tight neighborhoods, and larger environments, such that each block's environment can be reasonably approximated using a local linear model, evaluated using cross-validation on the RMSE in the neighborhood at its core.\n\nUsing the block-block distances, we define a tight neighborhood of each block containing at least min_blocks_in_neighborhood, min_metacells_in_neighborhood and min_covered_UMIs_in_neighborhood (note that the latter only counts UMIs of skeleton genes).\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nVectors\n\nblock @ covered_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of the all covered genes in each block.\n\nblock @ n_metacells::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of metacells in each block.\n\nMatrices\n\nblock, block @ maxskeletonfold_distance::Union{Float32, Float64} (optional): The maximal significant skeleton genes covered fractions fold factor between metacells of the blocks.\n\nblock, block @ meaneuclideanskeleton_distance::Union{Float32, Float64} (optional): The mean Euclidean skeleton genes covered fractions distance between the metacells of the blocks.\n\nOutputs\n\nMatrices\n\nblock, block @ isinenvironment::Bool (guaranteed): For each block, the (column) mask of nearby blocks in its expanded environment.\n\n\n\n\n\n","category":"function"},{"location":"compute_blocks.html#Index","page":"Compute Blocks","title":"Index","text":"","category":"section"},{"location":"compute_blocks.html","page":"Compute Blocks","title":"Compute Blocks","text":"Pages = [\"compute_blocks.md\"]","category":"page"},{"location":"gmara.html#Gmara","page":"Gmara","title":"Gmara","text":"","category":"section"},{"location":"gmara.html#Metacells.Gmara","page":"Gmara","title":"Metacells.Gmara","text":"Access gene names lists from Gmara.\n\nnote: Note\nAll the functions here are thread-safe and can also be invoked from multiple parallel processes using the same CACHE_DIR. This directory can even be shared between multiple users as long as they have read-write permissions to the shared directory. This should even work on NFS mounted volumes shared between multiple servers.\n\n\n\n\n\n","category":"module"},{"location":"gmara.html#Configuration","page":"Gmara","title":"Configuration","text":"","category":"section"},{"location":"gmara.html#Metacells.Gmara.CACHE_DIR","page":"Gmara","title":"Metacells.Gmara.CACHE_DIR","text":"The default ($HOME/.cache/gmara) location of the cache of downloaded Gmara data files.\n\nYou can override this by setting the METACELLS_GMARA_CACHE_DIR environment variable, or by passing an explicit cache_dir parameter to the functions.\n\nThe top-level under this is the version indicator, where main is always the latest and greatest version. Under each version we store the files in the same path as in github, with a .gz suffix for the compressed raw data, .jl_set.gz for serialized Julia set objects, and .lock for temporary lock files for coordinating between parallel processes.\n\n\n\n\n\n","category":"constant"},{"location":"gmara.html#Metacells.Gmara.TIMEOUT","page":"Gmara","title":"Metacells.Gmara.TIMEOUT","text":"The default timeout in seconds (10) for waiting for a lock file in the Gmara cache. If not positive, will wait forever. If a process crashes very badly then a lock file may be left behind and may need to be removed by hand to allow access for the data.\n\nYou can override this by setting the METACELLS_GMARA_TIMEOUT environment variable, or by passing an explicit timeout parameter to the functions.\n\n\n\n\n\n","category":"constant"},{"location":"gmara.html#Functions","page":"Gmara","title":"Functions","text":"","category":"section"},{"location":"gmara.html#Metacells.Gmara.normalize_gene_name","page":"Gmara","title":"Metacells.Gmara.normalize_gene_name","text":"normalize_gene_name(name::AbstractString; namespace::AbstractString)::AbstractString\n\nNormalize the a gene name in some namespace. In most namespaces, this means removing the .[0-9] version suffix from the name, and converting the name to upper case. To lookup a name in a list or a namespace, you need to normalize the query gene name accordingly. The UCSC namespace is an exception in that it is all-lower-case and the .[0-9] suffix seems to be an inherent part of the identifier.\n\n\n\n\n\n","category":"function"},{"location":"gmara.html#Metacells.Gmara.gmara_genes","page":"Gmara","title":"Metacells.Gmara.gmara_genes","text":"gmara_genes(;\n    species::AbstractString,\n    [namespace::AbstractString = ```\"GeneSymbol\"```,\n    list::Maybe{AbstractString} = ```nothing```,\n    version::AbstractString = ```\"main\"```,\n    cache_dir = CACHE_DIR,\n    timeout::Real = TIMEOUT,\n)::AbstractSet{<:AbstractString}\n\nReturn the set of names of a version of a list in a namespace of genes of some species. This returns all the names that are (probably) in the list; it a name isn't in the result, it is almost certain it does not belong in the list. As usual in Gmara, this includes everything that may be used as name, e.g. for Ensembl it includes genes, transcripts and proteins; for Symbol it includes approved and alises; etc. If the list is nothing, this just returns the set of known gene names in the namespace.\n\n\n\n\n\n","category":"function"},{"location":"gmara.html#Metacells.Gmara.set_gmara_genes_mask!","page":"Gmara","title":"Metacells.Gmara.set_gmara_genes_mask!","text":"set_gmara_genes_mask!(\n    daf::DafWriter;\n    species::AbstractString,\n    namespace::AbstractString,\n    [list::Maybe{AbstractString} = ```nothing```,\n    gene_names::AbstractString = ```\"name\"```,\n    property::Maybe{AbstractString} = ```nothing```,\n    cache_dir = CACHE_DIR,\n    timeout::Real = TIMEOUT,\n    overwrite::Bool = ```false```]\n)::Nothing\n\nSet a gene property mask in daf based on some version of a Gmara list of some namespace for some species. We match the gene_names (by default, just the unique names in the gene axis) with the list names and set the result mask as a per-gene property (by default, is_list). If list is nothing, this just marks the gene names that exist in the namespace. If overwrite, this will overwrite an existing property of the.array same name.\n\n\n\n\n\n","category":"function"},{"location":"gmara.html#Metacells.Gmara.empty_gmara_cache!","page":"Gmara","title":"Metacells.Gmara.empty_gmara_cache!","text":"empty_gmara_cache!()::Nothing\n\nAll requests are cached in-memory. This makes repeated requests cheap. This consumes some (modest amount of) memory; also, if the data in the server has been updated (which rarely happens), you will keep getting the old result. This function releases all the memory and forces all subsequent requests to query the server. In the common case the server tells us our disk cache data is up to date, we don't re-download it).\n\n\n\n\n\n","category":"function"},{"location":"gmara.html#Index","page":"Gmara","title":"Index","text":"","category":"section"},{"location":"gmara.html","page":"Gmara","title":"Gmara","text":"Pages = [\"gmara.md\"]","category":"page"},{"location":"contracts.html#Contracts","page":"Contracts","title":"Contracts","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts","page":"Contracts","title":"Metacells.Contracts","text":"Functions for defining a Contract for a metacells Daf data set @computation. This also serves as a vocabulary describing the data we keep when doing metacells based analysis, which is a solid basis for understanding what is going on. As Fred Brooks said: \"Show me your flowcharts and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won’t usually need your flowcharts; they’ll be obvious.\".\n\nWe often look at the log base 2 of the gene expression level. We use a regularization factor of 1e-5 to avoid a log of zero. This means the minimal log value is -16.6 and the maximal value for a well-behaved gene (~0.1% of the total UMIs of the cell) is -10. We typically look at the range -16 \"basically no expression\" to -10 \"respectably high expression\".\n\nIn the descriptions below, \"fold factor\" refers to the log base 2 of the ratio between expression levels. That is, we look at an interesting fold factor of ~6 between \"basically no expression\" and \"respectably high expression\". A fold factor (difference in logs) of ~3 (that is, ~8x expression level) is typically taken to be \"significant\" for a single gene between cells by the metacell algorithm. However lower fold factors may be significant, especially as the number of UMIs used to estimate the expression levels are larger (e.g., between expression levels of metacells). As a quick and useful heuristic, we don't consider fold factors between metacell genes to be meaningful unless the sum of the gene UMIs in both compared metacells is too low (below 40).\n\nGenes that are higher than -10 (that is, more than 0.1%) are \"bursty\", e.g. Hemoglobins and Cytokines. Sometimes such genes take more than 10% of the total UMIs of a cell! TODO: Special handling for such genes, as they effect the denominator for linear fraction estimations and overwhelm least-square approximations.\n\n\n\n\n\n","category":"module"},{"location":"contracts.html#Genes","page":"Contracts","title":"Genes","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.gene_axis","page":"Contracts","title":"Metacells.Contracts.gene_axis","text":"gene_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of sequenced genes. By convention we use gene symbols as the namespace of the genes, but this may be different depending on the data set.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Genes-Masks","page":"Contracts","title":"Genes Masks","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.gene_is_mitochondrial_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_mitochondrial_vector","text":"gene_is_mitochondrial_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of mitochondrial genes. These genes are typically excluded from the analysis as they are (mostly) unrelated to the biological behaviors of interest, and also have such a large and variable expression level that including them would skew the denominator when estimating linear gene expression level fractions.\n\nThis vector is created in a supervised way based on biological and technical considerations.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_ribosomal_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_ribosomal_vector","text":"gene_is_ribosomal_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of mitochondrial genes. These genes are typically excluded from the analysis, as they aren't always unrelated to the biological behaviors of interest, they have such a large and variable expression level that including them would skew the denominator when estimating linear gene expression level fractions.\n\nThis vector is created in a supervised way based on biological and technical considerations.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_excluded_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_excluded_vector","text":"gene_is_excluded_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that are excluded from consideration. These genes are either unrelated to the biological behaviors of interest and/or have such a large and variable expression level that including them would skew the denominator when estimating linear genes expression level fractions.\n\nThis vector is created in a supervised way based on biological and technical considerations.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_lateral_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_lateral_vector","text":"gene_is_lateral_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that are lateral to the biological behaviors of interest. These genes may satisfy all criteria for being in a group of cooperating genes, but the biological behavior they participate in isn't relevant to the behaviors of interest - for example, genes related to cell cycle or stress. Such genes make it harder to focus on the biological behaviors of interest. They are therefore masked out during some phases of the analysis. However, unlike excluded genes, we still track their expression level and take it into account (e.g., when removing outlier cells from metacells).\n\nThis vector is created in a supervised way based on biological considerations.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_marker_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_marker_vector","text":"gene_is_marker_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that distinguish between cell states. These genes have a significant expression level at some cell state, as well as a significant range of expression across all cell states, so can be used to distinguish between cell states. Non-marker genes are by definition not useful for such analysis, but marker genes aren't necessarily useful due to other considerations (e.g., they may be lateral genes).\n\nThis vector is populated by identify_marker_genes!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_marker_rank_vector","page":"Contracts","title":"Metacells.Contracts.gene_marker_rank_vector","text":"gene_marker_rank_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe relative ranks of the marker genes. The more the gene distinguishes between different cell states, the better (lower) rank it has. That is, 1 is the \"most\" marker gene. Non-marker genes are given an extremely high rank (that maximal the data type allows).\n\nThis vector is populated by rank_marker_genes!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_covered_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_covered_vector","text":"gene_is_covered_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that are covered by the model(s). When we construct some model(s) for approximating the manifold describing the cell behaviors, we focus only on these genes, ignoring the rest. This allows the model(s) to be more sensitive to variations in the covered genes, without the distraction of the noise from the rest. The covered genes are typically some subset of the marker genes; in particular, they don't include lateral genes. Properties that are computed using only the covered genes contain _covered_ in their name, e.g., covered_fraction vs. linear_fraction.\n\nThis vector is populated by identify_covered_genes!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_regulator_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_regulator_vector","text":"gene_is_regulator_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that regulate the expression level of other genes. These genes are expected to be at the core of the gene programs that describe the cell behaviors manifold.\n\nThis vector is populated by fetch_regulators!.\n\nnote: Note\nThese are not all the genes that bind to DNA (aka \"transcription factors\").\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_skeleton_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_skeleton_vector","text":"gene_is_skeleton_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that are used to predict the values of the rest of the (covered) genes. We assume that knowing the expression level of the skeleton genes is sufficient to reasonably estimate the expression level of the rest of the covered genes. For example, if two metacells have \"very close\" expression level of all the skeleton genes, we assume that these metacells are \"very similar\", without looking at the rest of the covered genes.\n\nThis vector is populated by identify_skeleton_genes!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_forbidden_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_forbidden_vector","text":"gene_is_forbidden_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that are forbidden from being used as skeleton genes.\n\nThis vector is created in a supervised way based on biological and technical considerations.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Cells","page":"Contracts","title":"Cells","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.cell_axis","page":"Contracts","title":"Metacells.Contracts.cell_axis","text":"cell_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of sequenced single cells. There's no convention for cell names, as long as they are unique. Typically some sort of barcode is used, possibly combined with a batch and/or plate and/or experiment identification. In the latter case it is recommended that batch and/or plate and/or experiment would also be created as explicit axes, to allow associating metadata with them instead of repeating it for each cell.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Cells-UMIs","page":"Contracts","title":"Cells UMIs","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.cell_gene_UMIs_matrix","page":"Contracts","title":"Metacells.Contracts.cell_gene_UMIs_matrix","text":"cell_gene_UMIs_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe number of UMIs collected for each gene for each cell. This is the measurement everything else is built on. This is some sampling of the ground truth of the number of RNA molecules of each gene in each cell. This suffers from randomness (only a small subset of the molecules are actually counted), and biases (some molecules are favored over others, depending on the specific technology and protocol used). More fundamentally, the total number of RNA molecules varies (sometimes wildly) between different cells.\n\nThe UMIs count is therefore very sparse and very noisy. The challenge of scRNA-seq analysis is to extract meaningful patterns (cooperating gene programs) that describe the cell behaviors based on this data.\n\nTo analyze this data, we are forced to normalize the UMIs counts to a fraction of the total. This is mostly meaningless in the single-cell level because we have so few UMIs per each cell (x,000 or x0,000 UMIs out of the x00,000 RNA molecules) and low-expressing (but still important) genes may have one or at most few UMIs.\n\nTherefore fractions are only computed for collection of cells. Metacells are defined as the smallest such collections that can be used to give meaningful fraction estimates (therefore maximizing sensitivity for capturing all cell behaviors). This is in contrast with classical methods that look at very large collections (cell \"types\").\n\nUsing fractions is sensitive to the choice of the denominator; a gene (or gene program) with very high expression would artificially reduce the fraction of the rest of the genes. We therefore exclude known troublesome genes from the denominator (e.g., mitochondrial and ribosomal genes). When constructing parametric models, we recompute the fractions to just the covered genes, to reduce the impact on the denominator of lateral genes (e.g., cell cycle). And when comparing fractions between different data sets, one must always renormalize the fractions to the common genes set.\n\nIdeally, we could somehow create an estimate of the concentration of each RNA molecule as this is in absolute units so is directly comparable across analysis methods and data sets. However, in addition to being dependent on the unknown total number of molecules in each cell, this also depends on the unknown and cell volume.\n\nThis data is obtained from scRNA-seq experiments.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_mitochondrial_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.cell_mitochondrial_UMIs_vector","text":"cell_mitochondrial_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of all the mitochondrial genes in each cell.\n\nThis vector is created in a supervised way, typically based on the naming convention that mitochondrial genes names match the pattern ^MT-.*$.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_ribosomal_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.cell_ribosomal_UMIs_vector","text":"cell_ribosomal_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of all the ribosomal genes in each cell.\n\nThis vector is created in a supervised way, typically based on the naming convention that mitochondrial genes names match the pattern ^RP[LS]-.*$.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_excluded_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.cell_excluded_UMIs_vector","text":"cell_excluded_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of all the excluded genes in each cell.\n\nThis vector is created in a supervised way based on biological and technical considerations. It typically includes mitochondrial and ribosomal genes, as well as other genes which are highly correlated with other excluded genes.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_total_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.cell_total_UMIs_vector","text":"cell_total_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of all the non-excluded genes in each cell.\n\nThis vector is populated by compute_cells_total_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_covered_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.cell_covered_UMIs_vector","text":"cell_covered_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of all the covered genes in each cell.\n\nThis vector is populated by compute_cells_covered_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Cells-masks","page":"Contracts","title":"Cells masks","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.cell_is_excluded_vector","page":"Contracts","title":"Metacells.Contracts.cell_is_excluded_vector","text":"cell_is_excluded_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of cells that are excluded from consideration. This can be due to any number of reasons - doublets, too low a number of UMIs, to high a percentage of excluded gene UMIs, etc. Excluded cells are not grouped into metacells etc., so they are ignored in all properties that sum UMIs per group (e.g., total_UMIs per metacell).\n\nThis vector is created in a supervised way based on biological and technical considerations.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells","page":"Contracts","title":"Metacells","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_axis","page":"Contracts","title":"Metacells.Contracts.metacell_axis","text":"metacell_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of metacells, which are minimal-sized groups of cells for robust fraction estimates. Each metacell is considered to be a robustly estimated point in the multi-dimensional manifold of cell states. Metacells may be very similar or very different from each other depending on how well a region of the manifold was sampled; that is, highly sampled cell states would have a large number of higher quality metacells that are more similar (dare one say, even \"identical\") to each other, while sparsely sampled cell states would have a smaller number of lower quality metacells that are more different from one another. At the threshold of the sensitivity of the algorithm, very rare cell states would be discarded as outliers, or not even appear in the data in the first place.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_metacell_vector","page":"Contracts","title":"Metacells.Contracts.cell_metacell_vector","text":"cell_metacell_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe unique metacell each cell belongs to. All the cells in the same metacell are assumed to have \"the same\" (relevant) biological state. This is the empty string if the cell does not belong to any metacell (is excluded or outlier).\n\nThis vector can be populated by any metacells-like algorithm (the original R metacells (1) algorithm, the Python metacells (2) algorithm, other similar algorithms).\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_n_cells_vector","page":"Contracts","title":"Metacells.Contracts.metacell_n_cells_vector","text":"metacell_n_cells_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe number of cells in each metacell.\n\nThis vector is populated by compute_metacells_n_cells!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells-UMIs","page":"Contracts","title":"Metacells UMIs","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_UMIs_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_UMIs_matrix","text":"metacell_gene_UMIs_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe total number of UMIs of each gene in the cells of each metacell.\n\nThis matrix is populated by compute_metacells_genes_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_total_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.metacell_total_UMIs_vector","text":"metacell_total_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of all the non-excluded genes in each metacell. This is used as the denominator for linear_fraction.\n\nThis vector is populated by compute_metacells_total_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_covered_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.metacell_covered_UMIs_vector","text":"metacell_covered_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of the covered genes in each metacell. This is used as the denominator for covered_fraction.\n\nThis vector is populated by compute_metacells_covered_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells-Fractions","page":"Contracts","title":"Metacells Fractions","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_linear_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_linear_fraction_matrix","text":"metacell_gene_linear_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe linear fraction of the UMIs of each non-excluded gene in each metacell, out of the total UMIs. This is the \"best\" estimate assuming unbiased multinomial sampling. However, this is sensitive to a few cells with very high expression levels (\"bursty\" genes), as these impact the denominator.\n\nThis matrix is populated by compute_metacells_genes_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_log_linear_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_log_linear_fraction_matrix","text":"metacell_gene_log_linear_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the linear fraction of the UMIs of each non-excluded gene in each metacell, out of the total UMIs. This adds some gene fraction regularization to deal with zero fractions. Using the log makes it easier to visualize, and the difference between log values (the \"fold factor\", log base 2 of the ratio between the expression levels) is a good measure of difference between gene expression levels.\n\nThis matrix is populated by compute_metacells_genes_log_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_covered_fraction_matrix","text":"metacell_gene_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe linear fraction of the UMIs of each covered gene in each metacell, out of the total covered UMIs. By considering only the covered genes this avoid the impact of highly-expressed lateral genes (e.g., cell cycle).\n\nThis matrix is populated by compute_metacells_genes_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_log_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_log_covered_fraction_matrix","text":"metacell_gene_log_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the linear fraction of the UMIs of each covered gene in each metacell, out of the total covered UMIs. This adds some gene fraction regularization to deal with zero fractions.\n\nThis matrix is populated by compute_metacells_genes_log_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_geomean_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_geomean_fraction_matrix","text":"metacell_gene_geomean_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe geomean fraction of the UMIs of each gene in each metacell. We use geomean in an attempt to combat the disproportionate effect of a few cells with very high gene expression (\"bursty\" genes), and then normalizes the fractions to sum to one. While effective, this has the unfortunate effect of inflating the value of weak genes.\n\nTODO: Get rid of this.\n\nThis matrix is populated by compute_metacells_genes_geomean_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_log_geomean_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_log_geomean_fraction_matrix","text":"metacell_gene_log_geomean_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the geomean fraction of the UMIs of each gene in each metacell. This adds some gene fraction regularization to deal with zero fractions.\n\nTODO: Get rid of this.\n\nThis matrix is populated by compute_metacells_genes_log_geomean_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells-Distances","page":"Contracts","title":"Metacells Distances","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_metacell_euclidean_skeleton_distance","page":"Contracts","title":"Metacells.Contracts.metacell_metacell_euclidean_skeleton_distance","text":"metacell_metacell_euclidean_skeleton_distance(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe Euclidean distance between the log of the covered fraction of the skeleton genes between the metacells.\n\nThis matrix is computed by compute_metacells_euclidean_distances!.\n\nTODO: Get rid of this?\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_metacell_max_skeleton_fold_distance","page":"Contracts","title":"Metacells.Contracts.metacell_metacell_max_skeleton_fold_distance","text":"metacell_metacell_max_skeleton_fold_distance(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe maximal significant fold factor between the covered fraction of skeleton genes between the metacells. This uses heuristics to require the fold factor be based on a sufficient number of UMIs to be robust.\n\nThis matrix may be populated by compute_metacells_max_skeleton_fold_distances!.\n\nTODO: Get rid of this?\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Blocks","page":"Contracts","title":"Blocks","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_axis","page":"Contracts","title":"Metacells.Contracts.block_axis","text":"block_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of blocks, which are distinct groups of metacells with \"very close\" cell state. The metacells in each block all have \"very close\" estimates of the covered fractions of the skeleton genes. Using blocks instead of metacells allows us to more uniformly sample the overall manifold. Highly sampled cell states would have blocks with larger number of higher-quality metacells, while sparsely sampled cell states would have blocks with fewer lower-quality metacells.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_block_vector","page":"Contracts","title":"Metacells.Contracts.metacell_block_vector","text":"metacell_block_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe unique block each metacell belongs to.\n\nThis vector is populated by compute_blocks!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_n_metacells_vector","page":"Contracts","title":"Metacells.Contracts.block_n_metacells_vector","text":"block_n_metacells_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe number of metacells in each block.\n\nThis vector is populated by compute_blocks_n_metacells!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_n_cells_vector","page":"Contracts","title":"Metacells.Contracts.block_n_cells_vector","text":"block_n_cells_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe number of cells in the metacells in each block.\n\nThis vector is populated by compute_blocks_n_cells!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Blocks-UMIs","page":"Contracts","title":"Blocks UMIs","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_gene_UMIs_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_UMIs_matrix","text":"block_gene_UMIs_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe total number of UMIs of each gene in each block.\n\nThis matrix is populated by compute_blocks_genes_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_total_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.block_total_UMIs_vector","text":"block_total_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of all the non-excluded genes in each block. This is used as the denominator for linear_fraction.\n\nThis vector is populated by compute_blocks_total_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_covered_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.block_covered_UMIs_vector","text":"block_covered_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of all the covered genes in each block. This is used as the denominator for covered_fraction.\n\nThis vector is populated by compute_blocks_covered_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Blocks-Fractions","page":"Contracts","title":"Blocks Fractions","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_gene_linear_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_linear_fraction_matrix","text":"block_gene_linear_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe linear fraction of the UMIs of each non-excluded gene out of the total UMIs in each block.\n\nThis matrix is populated by compute_blocks_genes_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_log_linear_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_log_linear_fraction_matrix","text":"block_gene_log_linear_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the linear fraction of the UMIs of each non-excluded gene out of the total UMIs in each block. This adds some gene fraction regularization to deal with zero fractions.\n\nThis matrix is populated by compute_blocks_genes_log_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_covered_fraction_matrix","text":"block_gene_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe linear fraction of the UMIs of each covered gene out of the total covered UMIs in each block.\n\nThis matrix is populated by compute_blocks_genes_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_log_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_log_covered_fraction_matrix","text":"block_gene_log_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the linear fraction of the UMIs of each covered gene out of the total covered UMIs in each block. This adds some gene fraction regularization to deal with zero fractions.\n\nThis matrix is populated by compute_blocks_genes_log_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Blocks-Distances","page":"Contracts","title":"Blocks Distances","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_block_mean_euclidean_skeleton_distance","page":"Contracts","title":"Metacells.Contracts.block_block_mean_euclidean_skeleton_distance","text":"block_block_mean_euclidean_skeleton_distance(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe mean Euclidean skeleton genes covered fractions distance between the metacells of the blocks.\n\nThis matrix may be computed by compute_blocks_mean_euclidean_distances!.\n\nTODO: Get rid of this?\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_block_max_skeleton_fold_distance","page":"Contracts","title":"Metacells.Contracts.block_block_max_skeleton_fold_distance","text":"block_block_max_skeleton_fold_distance(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe maximal significant skeleton genes covered fractions fold factor between metacells of the blocks.\n\nThis matrix may be populated by compute_blocks_max_skeleton_fold_distances!.\n\nTODO: Get rid of this?\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Blocks-Neighborhoods","page":"Contracts","title":"Blocks Neighborhoods","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_block_is_in_neighborhood_matrix","page":"Contracts","title":"Metacells.Contracts.block_block_is_in_neighborhood_matrix","text":"block_block_is_in_neighborhood_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nFor each block, the (column) mask of nearby blocks in its immediate neighborhood. The neighborhood consists of a small number of very close blocks.\n\nThis matrix is populated by compute_blocks_is_in_neighborhood!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_n_neighborhood_blocks_vector","page":"Contracts","title":"Metacells.Contracts.block_n_neighborhood_blocks_vector","text":"block_n_neighborhood_blocks_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of blocks in the neighborhood centered at each block.\n\nThis vector is populated by compute_blocks_n_neighborhood_blocks!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_n_neighborhood_metacells_vector","page":"Contracts","title":"Metacells.Contracts.block_n_neighborhood_metacells_vector","text":"block_n_neighborhood_metacells_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of metacells in the blocks of the neighborhood centered at each block.\n\nThis vector is populated by compute_blocks_n_neighborhood_metacells!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_n_neighborhood_cells_vector","page":"Contracts","title":"Metacells.Contracts.block_n_neighborhood_cells_vector","text":"block_n_neighborhood_cells_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of cells in the metacells in the blocks of the neighborhood centered at each block.\n\nThis vector is populated by compute_blocks_n_neighborhood_cells!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Blocks-Environments","page":"Contracts","title":"Blocks Environments","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_block_is_in_environment_matrix","page":"Contracts","title":"Metacells.Contracts.block_block_is_in_environment_matrix","text":"block_block_is_in_environment_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nFor each block, the (column) mask of nearby blocks in its expanded environment. The environment consists of a larger region than the neighborhood, which is still close to the center block.\n\nThis matrix is populated by compute_blocks_is_in_environment!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_n_environment_blocks_vector","page":"Contracts","title":"Metacells.Contracts.block_n_environment_blocks_vector","text":"block_n_environment_blocks_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of blocks in the environment centered at each block.\n\nThis vector is populated by compute_blocks_n_environment_blocks!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_n_environment_metacells_vector","page":"Contracts","title":"Metacells.Contracts.block_n_environment_metacells_vector","text":"block_n_environment_metacells_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of metacells in the blocks of the environment centered at each block.\n\nThis vector is populated by compute_blocks_n_environment_metacells!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_n_environment_cells_vector","page":"Contracts","title":"Metacells.Contracts.block_n_environment_cells_vector","text":"block_n_environment_cells_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of cells in the metacells in the blocks of the environment centered at each block.\n\nThis vector is populated by compute_blocks_n_environment_cells!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_is_environment_marker_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_is_environment_marker_matrix","text":"block_gene_is_environment_marker_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nA mask of covered genes that distinguish between cell states in each environment.\n\nThis matrix is populated by compute_blocks_genes_is_environment_markers!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Type-Annotations","page":"Contracts","title":"Type Annotations","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.type_axis","page":"Contracts","title":"Metacells.Contracts.type_axis","text":"type_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of types, which are distinct named biological cell states. Types are convenient labels manually assigned to large groups of cells, metacells, blocks, etc. Types are not associated with an exact biological cell state, but rather with a set of related biological cell states, possibly along a gradient of such states. The resolution of the type labels therefore depends on the data set and the type of analysis.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.type_color_vector","page":"Contracts","title":"Metacells.Contracts.type_color_vector","text":"type_color_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA unique color for each type, for visualizations.\n\nThis vector is created in a supervised way based on biological considerations and conventions (e.g., red blood cells are often given some red color). It is also possible to use Chameleon to automatically assign colors to cell types based on some gene expression levels.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_type_vector","page":"Contracts","title":"Metacells.Contracts.metacell_type_vector","text":"metacell_type_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe type each metacell belongs to. This can be assigned in many ways, from manual annotation to using projection methods on an annotated atlas. Often there are multiple type annotations due to different methods. By convention these alternate type vectors are named type.something (e.g., type.projected, type.manual) and the simple type is used for \"the\" type of each metacell.\n\nThis vector is created in a supervised way based on biological considerations. Alternatively, if one has a cell type vector from somewhere, it can be populated by compute_metacells_types_by_cells! which assigns to each metacell the most frequent type of the cells it contains.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_type_vector","page":"Contracts","title":"Metacells.Contracts.cell_type_vector","text":"cell_type_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe type each cell belongs to. By convention type is used for \"the\" type of the cell, which is compatible with the type of the metacell it belongs to, and other type.something are used for types computed in other ways, such as importing data from a type-annotated single-cell atlas, or by running some classifier directly on the cells.\n\nThis vector can be populated by compute_cells_types_by_metacells! which assigns to each cell the type of the metacell it belongs to.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_type_vector","page":"Contracts","title":"Metacells.Contracts.block_type_vector","text":"block_type_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe type each block belongs to. This is typically taken to be the most frequent metacell type in the block.\n\nThis vector is populated by compute_blocks_types! based on the metacell types in each block.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Modules","page":"Contracts","title":"Modules","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.module_axis","page":"Contracts","title":"Metacells.Contracts.module_axis","text":"module_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of modules, which are groups of genes that together can predict the rest of the covered genes. Each module is based on a single anchor regulator gene, and may contain additional regulator and regular genes. The set and composition of modules varies between blocks across the manifold. The names of the modules are the names of their anchors (for interpretability) followed by a .MOD suffix (to clarify this is the name of a module and not a gene).\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.module_anchor_gene_vector","page":"Contracts","title":"Metacells.Contracts.module_anchor_gene_vector","text":"module_anchor_gene_vector(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe anchor gene each module is based on. Even though the \"same\" module in different blocks is based on the same anchor gene, the rest of the composition of the module may vary wildly, even between neighboring blocks.\n\nThis matrix is populated by compute_blocks_modules!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_module_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_module_matrix","text":"block_gene_module_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe module each gene belongs to in each block. Most genes do not belong to any module and therefore have an empty string as the value.\n\nThis matrix is populated by compute_blocks_modules!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_module_is_found_matrix","page":"Contracts","title":"Metacells.Contracts.block_module_is_found_matrix","text":"block_module_is_found_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nA mask of the modules that were found for each block. Due to Daf limitations, the modules axis must cover all the modules of all the blocks. This mask specifies which of the modules were actually found for each of the blocks.\n\nThis matrix is populated by compute_blocks_modules!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_module_is_strong_matrix","page":"Contracts","title":"Metacells.Contracts.block_module_is_strong_matrix","text":"block_module_is_strong_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nA mask of the strong modules that have enough UMIs in enough cells. Since cells have much less UMIs than metacells, not all modules have a high enough number of UMIs in enough cells to be useful.\n\nThis matrix is populated by compute_blocks_modules_is_strong!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_module_n_genes_matrix","page":"Contracts","title":"Metacells.Contracts.block_module_n_genes_matrix","text":"block_module_n_genes_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe number of genes in each gene module in each block. This is zero for the extra (not-found) gene modules.\n\nThis matrix is populated by compute_blocks_modules_n_genes!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_module_n_skeletons_matrix","page":"Contracts","title":"Metacells.Contracts.block_module_n_skeletons_matrix","text":"block_module_n_skeletons_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe number of skeleton genes in each gene module in each block. This is zero for the extra (not-found) gene modules.\n\nThis matrix is populated by compute_blocks_modules_n_skeletons!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_metacell_module_environment_total_UMIs_tensor","page":"Contracts","title":"Metacells.Contracts.block_metacell_module_environment_total_UMIs_tensor","text":"block_metacell_module_environment_total_UMIs_tensor(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total UMIs of each environment module in each environment metacell. This is zero for metacells that are not part of the block's environment, or modules that aren't found in that environment.\n\nThis vector is populated by compute_block_metacell_module_environment_total_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_metacell_module_environment_linear_fraction_tensor","page":"Contracts","title":"Metacells.Contracts.block_metacell_module_environment_linear_fraction_tensor","text":"block_metacell_module_environment_linear_fraction_tensor(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe linear fraction of the total UMIs of each environment module in each environment metacell, out of the total UMIs. This is zero for metacells that are not part of the block's environment, or modules that aren't found in that environment.\n\nThis vector is populated by compute_block_metacell_module_environment_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_metacell_module_environment_log_linear_fraction_tensor","page":"Contracts","title":"Metacells.Contracts.block_metacell_module_environment_log_linear_fraction_tensor","text":"block_metacell_module_environment_log_linear_fraction_tensor(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe log base 2 of the linear fraction of the total UMIs of each environment module in each environment metacell, out of the total UMIs. This adds some gene fraction regularization to deal with zero fractions. This is zero for metacells that are not part of the block's environment, or modules that aren't found in that environment.\n\nThis vector is populated by compute_block_metacell_module_environment_log_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_metacell_module_environment_covered_fraction_tensor","page":"Contracts","title":"Metacells.Contracts.block_metacell_module_environment_covered_fraction_tensor","text":"block_metacell_module_environment_covered_fraction_tensor(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe linear fraction of the total UMIs of each environment module in each environment metacell, out of the total covered UMIs. This is zero for metacells that are not part of the block's environment, or modules that aren't found in that environment.\n\nThis vector is populated by compute_block_metacell_module_environment_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_metacell_module_environment_log_covered_fraction_tensor","page":"Contracts","title":"Metacells.Contracts.block_metacell_module_environment_log_covered_fraction_tensor","text":"block_metacell_module_environment_log_covered_fraction_tensor(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe log base 2 of the linear fraction of the total UMIs of each environment module in each environment metacell, out of the total covered UMIs. This adds some gene fraction regularization to deal with zero fractions. This is zero for metacells that are not part of the block's environment, or modules that aren't found in that environment.\n\nThis vector is populated by compute_block_metacell_module_environment_log_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Index","page":"Contracts","title":"Index","text":"","category":"section"},{"location":"contracts.html","page":"Contracts","title":"Contracts","text":"Pages = [\"contracts.md\"]","category":"page"},{"location":"analyze_genes.html#Analyze-Genes","page":"Analyze Genes","title":"Analyze Genes","text":"","category":"section"},{"location":"analyze_genes.html#Metacells.AnalyzeGenes","page":"Analyze Genes","title":"Metacells.AnalyzeGenes","text":"Do simple per-gene analysis.\n\n\n\n\n\n","category":"module"},{"location":"analyze_genes.html#Metacells.AnalyzeGenes.identify_marker_genes!","page":"Analyze Genes","title":"Metacells.AnalyzeGenes.identify_marker_genes!","text":"function identify_marker_genes!(\n    daf::DafWriter;\n    min_marker_gene_max_fraction::AbstractFloat = ```0.0001```,\n    min_marker_gene_range_fold::Real = ```2```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nIdentify the genes that distinguish at least one metacell from the rest. Such genes are called \"marker\" genes as they (potentially) mark specific cell states. If overwrite, will overwrite an existing is_marker mask.\n\nMarker genes are genes which:\n\nHave a maximal gene expression level of at least min_marker_gene_max_fraction, and\nHave a range of expression of at least min_marker_gene_range_fold between the maximal and minimal (log base 2) of the expression level.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nMatrices\n\ngene, metacell @ linear_fraction::Union{Float32, Float64} (required): The linear fraction of the UMIs of each non-excluded gene in each metacell, out of the total UMIs.\n\ngene, metacell @ loglinearfraction::Union{Float32, Float64} (required): The log base 2 of the linear fraction of the UMIs of each non-excluded gene in each metacell, out of the total UMIs.\n\nOutputs\n\nVectors\n\ngene @ is_marker::Bool (guaranteed): A mask of genes that distinguish between cell states.\n\n\n\n\n\n","category":"function"},{"location":"analyze_genes.html#Metacells.AnalyzeGenes.rank_marker_genes!","page":"Analyze Genes","title":"Metacells.AnalyzeGenes.rank_marker_genes!","text":"function rank_marker_genes!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nCompute the relative ranks of marker genes.\n\nCompute the median of the (log base 2) of the gene expression level for each marker gene across all the metacells.\nCompute the per-marker-per-metacell fold factor (absolute difference of the log expression from the median).\nRank the markers for each metacell (1 having the largest fold factor relative to the median).\nFor each marker, give it a priority which is a tuple of (1) the minimal rank it has in all metacells (2) the maximal fold it has in metacells where it has that rank (negated).\nSort the markers according to this priority.\n\nNon-marker genes are given a rank of typemax(UInt32) regardless of their expression level in the metacells.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ is_marker::Bool (required): A mask of genes that distinguish between cell states.\n\nMatrices\n\ngene, metacell @ loglinearfraction::Union{Float32, Float64} (required): The log base 2 of the linear fraction of the UMIs of each non-excluded gene in each metacell, out of the total UMIs.\n\nOutputs\n\nVectors\n\ngene @ marker_rank::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The ralative ranks of the marker genes.\n\n\n\n\n\n","category":"function"},{"location":"analyze_genes.html#Metacells.AnalyzeGenes.identify_covered_genes!","page":"Analyze Genes","title":"Metacells.AnalyzeGenes.identify_covered_genes!","text":"function identify_covered_genes!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nIdentify the genes that will be approximated by the local linear programs. Picking them is simple: we cover all marker genes, that are not lateral.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ is_marker::Bool (required): A mask of genes that distinguish between cell states.\n\ngene @ is_lateral::Bool (required): A mask of genes that are lateral to the biological behaviors of interest.\n\nOutputs\n\nVectors\n\ngene @ is_covered::Bool (guaranteed): A mask of genes that are covered by the model(s).\n\n\n\n\n\n","category":"function"},{"location":"analyze_genes.html#Metacells.AnalyzeGenes.identify_skeleton_genes!","page":"Analyze Genes","title":"Metacells.AnalyzeGenes.identify_skeleton_genes!","text":"function identify_skeleton_genes!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nIdentify the skeleton genes that will be used to predict the rest of the (covered) genes. We just pick the covered genes that are also regulators, and are not forbidden.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the model(s).\n\ngene @ is_regulator::Bool (required): A mask of genes that regulate the expression level of other genes.\n\ngene @ is_forbidden::Bool (required): A mask of genes that are forbidden from being used as skeleton genes.\n\nOutputs\n\nVectors\n\ngene @ is_skeleton::Bool (guaranteed): A mask of genes that are used to predict the values of the rest of the (covered) genes.\n\n\n\n\n\n","category":"function"},{"location":"analyze_genes.html#Metacells.AnalyzeGenes.fetch_regulators!","page":"Analyze Genes","title":"Metacells.AnalyzeGenes.fetch_regulators!","text":"fetch_regulators!(\n    daf::DafWriter;\n    species::AbstractString,\n    namespace::AbstractString = ```\"GeneSymbol\"```,\n    version::AbstractString = ```\"main\"```,\n    cache_dir = ```\"/Users/obk/.cach...\" (23)```,\n    timeout::Real = ```10```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nFetch the names of transcription factor genes from Gmara and create a mask based on them. These genes will be assumed to be the core genes driving gene programs that describe cell behavior.\n\n\n\n\n\n","category":"function"},{"location":"analyze_genes.html#Index","page":"Analyze Genes","title":"Index","text":"","category":"section"},{"location":"analyze_genes.html","page":"Analyze Genes","title":"Analyze Genes","text":"Pages = [\"analyze_genes.md\"]","category":"page"},{"location":"analyze_cells.html#Analyze-Cells","page":"Analyze Cells","title":"Analyze Cells","text":"","category":"section"},{"location":"analyze_cells.html#Metacells.AnalyzeCells","page":"Analyze Cells","title":"Metacells.AnalyzeCells","text":"Do simple per-cell analysis.\n\n\n\n\n\n","category":"module"},{"location":"analyze_cells.html#Metacells.AnalyzeCells.compute_cells_total_UMIs!","page":"Analyze Cells","title":"Metacells.AnalyzeCells.compute_cells_total_UMIs!","text":"function compute_cells_total_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nCompute the total UMIs of the genes in each cell.\n\nInputs\n\nAxes\n\ncell (required): Sequenced single cells.\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ is_excluded::Bool (required): A mask of genes that are excluded from consideration.\n\nMatrices\n\ngene, cell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of UMIs collected for each gene for each cell.\n\nOutputs\n\nVectors\n\ncell @ total_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of UMIs of all the non-excluded genes in each cell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_cells.html#Metacells.AnalyzeCells.compute_cells_covered_UMIs!","page":"Analyze Cells","title":"Metacells.AnalyzeCells.compute_cells_covered_UMIs!","text":"function compute_cells_covered_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nCompute the total UMIs of the covered genes in each cell.\n\nInputs\n\nAxes\n\ncell (required): Sequenced single cells.\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the model(s).\n\nMatrices\n\ngene, cell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of UMIs collected for each gene for each cell.\n\nOutputs\n\nVectors\n\ncell @ covered_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of UMIs of all the covered genes in each cell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_cells.html#Index","page":"Analyze Cells","title":"Index","text":"","category":"section"},{"location":"analyze_cells.html","page":"Analyze Cells","title":"Analyze Cells","text":"Pages = [\"analyze_cells.md\"]","category":"page"},{"location":"anndata_format.html#AnnData-Format","page":"AnnData Format","title":"AnnData Format","text":"","category":"section"},{"location":"anndata_format.html#Metacells.AnnDataFormat","page":"AnnData Format","title":"Metacells.AnnDataFormat","text":"Import and export cells and metacells data from/to h5ad files. This allows moving data between the old Python/C++ based AnnData world and the brave new Julia based Daf world.\n\nThe expected flow is as follows:\n\nCreate a Daf repository for the raw input cells and import the raw cells h5ad into it using import_cells_h5ad!.\nAlternatively, import just the clean cells h5ad into it, but that would be leaving out some of the data so is not recommended.\nCreate another Daf repository for the metacells, chain it to the cells repository, and import the metacells into it using import_metacells_h5ad!. Give this the cells-with-metacells data h5ad - only the assignment of cells to metacells will be imported from it.\nIf you have any per-cell or per-gene computed data in the cells-with-metacells data h5ad (unlikely, as computed data typically goes into the metacells h5ad), import it into the chained (metacells) repository using import_cells_h5ad!.\nCreate a type axis in the chained metacells Daf repository using reconstruct_type_axis!.\n\n\n\n\n\n","category":"module"},{"location":"anndata_format.html#Metacells.AnnDataFormat.import_cells_h5ad!","page":"AnnData Format","title":"Metacells.AnnDataFormat.import_cells_h5ad!","text":"function import_cells_h5ad!(\n    daf::DafWriter;\n    cells_h5ad::AbstractString,\n    copy_data::Maybe{CopyAnnData} = ```nothing```,\n    bestify::Bool = ```true```,\n    min_sparse_saving_fraction::AbstractFloat = ```0.25```,\n    overwrite::Bool = ```false```,\n    insist::Bool = ```false```,\n)::Nothing\n\nImport an AnnData based cells dataset into a destination daf data set. Ideally you'd copy the full (raw) cells into an empty Daf repository. Then, you'd treat this repository as read-only, and copy the metacells data using import_metacells_h5ad! into a separate Daf repository chained with the read-only cells repository. This allows separate alternative metacells computations to share the read-only cells data.\n\nYou can copy an h5ad file containing just the clean cells on top of the raw cells data, to capture any data computed during or after computing the metacells. You may need to specify the copy_data to specify defaults for values of properties that exist only for clean cells and/or genes. Or, you can skip copying the raw data altogether, copying just the clean data into the base cells repository, though this is less recommended as you are needlessly discarding data that may prove to be useful later.\n\nThe bestify, min_sparse_saving_fraction, overwrite, and insist have their usual meaning from Daf's copying functions.\n\nWhen copying, we apply the following general rules:\n\nA something_gene per-gene property and/or something_cell per-cell property are renamed to is_something, (and given a default of false), because Daf (unlike AnnData) has no problem with properties with the same name for different axes.\nSimilarly {gene,cell}[s]_something_module and something_{gene,cell}[s]_module properties are renamed to something_module. We add 1 to the value and store the results in a UInt32; that is, in Daf, module indices are 1-based, and 0 is \"no module\".\nAny something_umis is renamed to something_UMIs, given a default of 0, and stored as a UInt32.\n\nAnd we make the following special exceptions:\n\nScalars:\n\nWe do not copy the __name__ scalar.\nAll other scalars are copied as-is.\n\nPer-cell-per-gene:\n\nThe X matrix is renamed to UMIs, and stored as a UInt32.\nNo other per-cell-per-gene matrix is copied by default.\n\nPer-gene:\n\nThe per-gene correction_factor is given the default value 0.\nThe fitted per-gene vector is renamed to is_fitted and given the default false.\nThe significant_inner_folds_count per-gene property is stored as a UInt32 and given the default 0.\nThe full_gene_index property is not copied. Either you import the full (raw) data or you don't.\nAll other vectors are copied as-is.\n\nPer-cell:\n\nThe full_cell_index property is not copied. Either you import the full (raw) data or you don't.\nThe metacell, metacell_name, metacell_level, most_similar and most_similar_name per-cell properties are not copied. To import these, use import_metacells_h5ad!.\nAll other vectors are copied as-is.\n\nnote: Note\nIt is common to manually call reconstruct_axis! on the result to create additional axes (e.g., if the cells were collected from a set of batches and some properties are actually per-batch).\n\n\n\n\n\n","category":"function"},{"location":"anndata_format.html#Metacells.AnnDataFormat.import_metacells_h5ad!","page":"AnnData Format","title":"Metacells.AnnDataFormat.import_metacells_h5ad!","text":"function import_metacells_h5ad!(\n    daf::DafWriter;\n    cells_h5ad::AbstractString,\n    metacells_h5ad::AbstractString,\n    copy_data::Maybe{CopyAnnData} = ```nothing```,\n    bestify::Bool = ```true```,\n    min_sparse_saving_fraction::AbstractFloat = ```0.25```,\n    overwrite::Bool = ```false```,\n    insist::Bool = ```false```,\n)::Nothing\n\nImport an AnnData based metacells dataset into a destination daf data set. It is expected that you have first imported the per-cell data. Ideally you'd create a new empty repository for the metacells data and chained it on top of the per-cell repository, which you'd keep read-only to allow sharing it when you (inevitably) compute different metacells for it.\n\nThis behaves similarly to import_cells_h5ad!, specifically the generic rules (except that we copy per-metacell properties and not per-cell properties so the rules are adjusted accordingly), and we make the following special exceptions:\n\nPer-metacell-per-gene:\n\nThe X matrix is renamed to fraction and always stored as Float32.\nThe corrected_fraction matrix is always stored as Float32.\nThe essential matrix is renamed to is_essential.\nThe essential, fitted, and misfit matrices are renamed to is_essential, is_fitted and is_misfit, respectively.\nThe inner_fold, inner_stdev_log, projected_fold, projected_fraction matrices are always stored as Float32.\nThe total_umis matrix is renamed to UMIs and always stored as UInt32.\nThe zeros matrix is always stored as UInt32.\nAll other matrices are copied as-is.\n\nScalars and Per-gene:\n\nSame as in import_cells_h5ad!\n\nPer-cell:\n\nThe only properties we copy per cell are metacell_name (renamed to metacell with a default of the empty string), and similarly most_similar_name (renamed to most_similar.metacell, same default). That's the only reason we have a cells_h5ad parameter. You should therefore pass here the cells-with-metacells and not the clean cells h5ad.\n\nPer-metacell:\n\nThe metacells_level property is renamed to level.\nThe similar property is renamed to is_similar.\nThe type property is copied. If \"the\" type property of the metacells is different, use copy_data to rename it to type to match the Daf naming convention.\nAll other vectors are copied as-is.\n\nPer-metacell-per-metacell:\n\nThe obs_outgoing_weights matrix is renamed to outgoing_weights and always stored as Float32.\nAll other matrices are copied as-is.\n\nnote: Note\nIt is common to manually call reconstruct_type! on the result to create a type axis.\n\n\n\n\n\n","category":"function"},{"location":"anndata_format.html#Metacells.AnnDataFormat.reconstruct_type_axis!","page":"AnnData Format","title":"Metacells.AnnDataFormat.reconstruct_type_axis!","text":"reconstruct_type!(\n    daf::DafWriter,\n    base_axis::AbstractString = ```\"metacell\"```,\n    type_property::AbstractString = ```\"type\"```,\n    type_axis::AbstractString = ```\"type\"```,\n    empty_type::Maybe{AbstractString} = ```nothing```,\n    type_colors_csv::Maybe{AbstractString} = ```nothing```,\n    implicit_properties::Maybe{AbstractSet{<:AbstractString}} = ```nothing```,\n    skipped_properties::Maybe{AbstractSet{<:AbstractString}} = ```2 x Str (Set)```,\n    properties_defaults::Maybe{Dict} = ```nothing```,\n)::Nothing\n\nCreate a type axis after importing data containing type annotations. By default this will look for a type per metacell, but if you have type annotation per cell (which is not simply the type of the metacell they belong to), you can also use this for the cells.\n\nBy default this assumes that you have imported \"the\" type annotation to a property called \"type\", and that you would like the new type axis to be called \"type\" as well. If you want to import secondary types (or per-cell types), change these via the type_property and type_axis parameters.\n\nIf the type is equal to empty_type it is replaced with the empty string to match the Daf conventions for \"no value\" for string properties. Any set of per-gene properties named something_gene_of_type is converted to a per-gene-per-type matrix called is_something (with a default of false).\n\nOtherwise, this is mostly just a wrapper for reconstruct_axis!. It can be further enhanced by specifying a type_colors_csv file mapping type names to colors. This should be a comma or tab separated file containing at least two columns, one named \"color\" and one with the same name as the type_property. If this CSV file contains types that aren't actually used in the data, you will have to specify a default value for any other per-type property in properties_defaults.\n\nnote: Note\nMost metacells data has type annotations and colors associated with types, so it is highly recommended you invoke this to capture these into the Daf repository. This will enable all types (:-) of downstream processing, coloring graphs, etc.\n\n\n\n\n\n","category":"function"},{"location":"anndata_format.html#Metacells.AnnDataFormat.CopyAnnData","page":"AnnData Format","title":"Metacells.AnnDataFormat.CopyAnnData","text":"Specify how to copy data from AnnData to Daf. The key is simply a vector or matrix name (ignoring axes), and the value is either nothing to ignore the data, or a tuple with the name of the destination Daf property and an optional value to use for missing entries (raw-only cells and/or genes).\n\n\n\n\n\n","category":"type"},{"location":"anndata_format.html#Index","page":"AnnData Format","title":"Index","text":"","category":"section"},{"location":"anndata_format.html","page":"AnnData Format","title":"AnnData Format","text":"Pages = [\"anndata_format.md\"]","category":"page"},{"location":"compute_modules.html#Compute-Modules","page":"Compute Modules","title":"Compute Modules","text":"","category":"section"},{"location":"compute_modules.html#Metacells.ComputeModules","page":"Compute Modules","title":"Metacells.ComputeModules","text":"Group covered genes in each environment to modules, each associated with some anchor gene.\n\n\n\n\n\n","category":"module"},{"location":"compute_modules.html#Metacells.ComputeModules.compute_blocks_modules!","page":"Compute Modules","title":"Metacells.ComputeModules.compute_blocks_modules!","text":"function compute_blocks_modules!(\n    daf::DafWriter;\n    mean_genes_per_cluster::Integer = ```200```,\n    anchor_correlation_genes::Integer = ```30```,\n    min_anchor_correlation_genes_fraction::AbstractFloat = ```0.05```,\n    max_anchor_correlation_genes_fraction::AbstractFloat = ```0.5```,\n    min_gene_migration_correlation::AbstractFloat = ```0.7```,\n    max_anchor_kept_cluster_genes_baseline::Integer = ```100```,\n    min_anchor_kept_cluster_genes_likelihood::AbstractFloat = ```1.5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nGroup covered genes in each environment to modules, each associated with some anchor gene.\n\nFor each block:\n\nCompute the correlation of the expression of the covered genes across all metacells in the block's environment.\nCluster the genes based on this correlation, using Ward. The number of clusters is such that the mean number of genes per cluster is at least mean_genes_per_cluster.\nFor each cluster, pick an anchor gene out of the skeleton genes. For each skeleton, look at its worst correlation in the top anchor_correlation_genes (but at least min_anchor_correlation_genes_fraction and at most max_anchor_correlation_genes_fraction). Pick as anchor the skeleton gene with the highest result.\nFor each gene in the cluster, keep it in the anchor's module if it is more correlated with the anchor than with any other anchor. Any gene with a correlation of more than min_gene_migration_correlation with some anchor is moved to the module of its most correlated anchor, regardless of the original cluster it was in.\nFor each cluster, consider the up to max_anchor_kept_cluster_genes_baseline genes most correlated with the cluster's anchor. If the fraction of the most correlated max_anchor_kept_cluster_genes_baseline genes that were kept in the anchor module is less than min_anchor_kept_cluster_genes_likelihood times the base fraction of 1/number of anchors, then discard the anchor.\nThe result is one module per anchor with the genes that were kept from its original cluster or were migrated to it. Some (most) genes will not participate in any module.\n\nWe name the resulting modules after their anchor gene for interpretability, but add a .MOD suffix to clarify this is the name of a module and not of a gene. It is possible that an anchor in one block will end up being a member of a different anchor's module in a neighbouring block, or even not to be used in any of the neighbouring block gene modules.\n\nDue to Daf limitations, the modules axis must therefore be the union of all the modules from all the blocks, so we provide an is_found mask to specify which module is used for each block.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nVectors\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\ngene @ is_skeleton::Bool (required): A mask of genes that are used to predict the values of the rest of the (covered) genes.\n\nMatrices\n\nblock, block @ isinenvironment::Bool (required): For each block, the (column) mask of nearby blocks in its expanded environment.\n\nblock, gene @ isenvironmentmarker::Bool (required): A mask of covered genes that distinguish between cell states in each environment.\n\nmetacell, gene @ logcoveredfraction::Union{Float32, Float64} (required): The log base 2 of the linear fraction of the UMIs of each covered gene in each metacell, out of the total covered UMIs.\n\nOutputs\n\nAxes\n\nmodule (guaranteed): Groups of genes that together predict the rest of the covered genes.\n\nVectors\n\nmodule @ gene.anchor::AbstractString (guaranteed): The anchor gene each module is based on.\n\nMatrices\n\nblock, module @ is_found::Bool (guaranteed): A mask of the modules that were found for each block.\n\nblock, gene @ module::AbstractString (guaranteed): The module each gene belongs to in each block.\n\n\n\n\n\n","category":"function"},{"location":"compute_modules.html#Index","page":"Compute Modules","title":"Index","text":"","category":"section"},{"location":"compute_modules.html","page":"Compute Modules","title":"Compute Modules","text":"Pages = [\"compute_blocks_modules.md\"]","category":"page"},{"location":"analyze_metacells.html#Analyze-Metacells","page":"Analyze Metacells","title":"Analyze Metacells","text":"","category":"section"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells","text":"Do simple metacells analysis.\n\n\n\n\n\n","category":"module"},{"location":"analyze_metacells.html#Counts","page":"Analyze Metacells","title":"Counts","text":"","category":"section"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_n_cells!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_n_cells!","text":"function compute_metacells_n_metacells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of metacells per metacell.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\ncell (required): Sequenced single cells.\n\nVectors\n\ncell @ metacell::AbstractString (required): The unique metacell each cell belongs to.\n\nOutputs\n\nVectors\n\nmetacell @ n_cells::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The number of cells in each metacell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#UMIs","page":"Analyze Metacells","title":"UMIs","text":"","category":"section"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_UMIs!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_UMIs!","text":"function compute_metacells_genes_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nInputs\n\nAxes\n\ncell (required): Sequenced single cells.\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ncell @ metacell::AbstractString (required): The unique metacell each cell belongs to.\n\nMatrices\n\ngene, cell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of UMIs collected for each gene for each cell.\n\nOutputs\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of UMIs of each gene in the cells of each metacell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_total_UMIs!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_total_UMIs!","text":"function compute_metacells_total_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of UMIs used to estimate the fraction of all the genes in each metacell.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ is_excluded::Bool (required): A mask of genes that are excluded from consideration.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs of each gene in the cells of each metacell.\n\nOutputs\n\nVectors\n\nmetacell @ total_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of UMIs of all the non-excluded genes in each metacell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_covered_UMIs!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_covered_UMIs!","text":"function compute_metacells_covered_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total UMIs of covered genes per metacell.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the model(s).\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs of each gene in the cells of each metacell.\n\nOutputs\n\nVectors\n\nmetacell @ covered_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of the covered genes in each metacell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Linear-Fractions","page":"Analyze Metacells","title":"Linear Fractions","text":"","category":"section"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_linear_fractions!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_linear_fractions!","text":"function compute_metacells_genes_linear_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nAn estimated linear fraction of the UMIs of each gene in each metacell. This is just the total UMIs of the gene in the metacell divided by the total UMIs of the metacell, which is the \"best\" estimate assuming multinomial sampling noise. However, this is sensitive to a few cells with very high expression levels (\"bursty\" genes).\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ is_excluded::Bool (required): A mask of genes that are excluded from consideration.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs of each gene in the cells of each metacell.\n\nOutputs\n\nMatrices\n\ngene, metacell @ linear_fraction::Union{Float32, Float64} (guaranteed): The linear fraction of the UMIs of each non-excluded gene in each metacell, out of the total UMIs.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_log_linear_fractions!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_log_linear_fractions!","text":"function compute_metacells_genes_log_linear_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe log base 2 of the estimated linear fraction of the UMIs of each gene in each metacell. This adds the gene_fraction_regularization to deal with zero fractions.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nMatrices\n\ngene, metacell @ linear_fraction::Union{Float32, Float64} (required): The linear fraction of the UMIs of each non-excluded gene in each metacell, out of the total UMIs.\n\nOutputs\n\nMatrices\n\ngene, metacell @ loglinearfraction::Union{Float32, Float64} (guaranteed): The log base 2 of the linear fraction of the UMIs of each non-excluded gene in each metacell, out of the total UMIs.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Covered-Fractions","page":"Analyze Metacells","title":"Covered Fractions","text":"","category":"section"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_covered_fractions!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_covered_fractions!","text":"function compute_metacells_genes_covered_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nAn estimated linear fraction of the UMIs of each covered gene in each metacell. By considering only the covered genes this avoid the impact of highly-expressed lateral genes (e.g., cell cycle). Otherwise is similar to compute_metacells_genes_linear_fractions!.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the model(s).\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs of each gene in the cells of each metacell.\n\nOutputs\n\nMatrices\n\ngene, metacell @ covered_fraction::Union{Float32, Float64} (guaranteed): The linear fraction of the UMIs of each covered gene in each metacell, out of the total covered UMIs.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_log_covered_fractions!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_log_covered_fractions!","text":"function compute_metacells_genes_log_covered_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe log base 2 of the estimated linear fraction of the UMIs of each covered gene in each metacell. This adds the gene_fraction_regularization to deal with zero fractions.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nMatrices\n\ngene, metacell @ covered_fraction::Union{Float32, Float64} (required): The linear fraction of the UMIs of each covered gene in each metacell, out of the total covered UMIs.\n\nOutputs\n\nMatrices\n\nmetacell, gene @ logcoveredfraction::Union{Float32, Float64} (guaranteed): The log base 2 of the linear fraction of the UMIs of each covered gene in each metacell, out of the total covered UMIs.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Geomean-Fractions","page":"Analyze Metacells","title":"Geomean Fractions","text":"","category":"section"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_geomean_fractions!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_geomean_fractions!","text":"compute_metacells_genes_geomean_fractions!(\n    daf::DafWriter;\n    UMIs_regularization::AbstractFloat = ```0.0625```,\n    min_downsamples::Integer = ```750```,\n    min_downsamples_quantile::AbstractFloat = ```0.05```,\n    max_downsamples_quantile::AbstractFloat = ```0.5```,\n    rng::AbstractRNG = default_rng(),\n    overwrite::Bool = ```false```,\n)::Nothing\n\nGiven an assignment of cells to metacell, compute an geomean estimation of the fraction of UMIs of each gene for each metacell.\n\nThe linear way to do this would be to just take the total UMIs of the gene out of the total UMIs of the metacell. However, this method has a weakness; a single strong cell with a \"very different\" fraction of the gene will dominate (that is, the method is sensitive to outliers).\n\nInstead, we take the geometric mean of the fractions of the gene in the cells. This however raises a few issues we need to deal with:\n\nGenes with zero UMIs are a problem; to combat this, we add a UMIs_regularization factor when computing the fractions, take the geomean, and subtract the regularization at the end (so all-zero genes will still get a zero overall fraction).\nWe want to give more weight to cells with more UMIs, so we use a scaled geomean. The weight we give to each cell is the log of the total number of UMIs in it.\nThe geomean fractions of all the genes in a metacell do not sum to one, so we scale them. This has the unfortunate side effect that the end result does not obey a nice relation to the linear fraction of the gene in each of the cells; in particular, the final result might be higher than all of these per-cell fractions (ouch).\n\nThis raises an important point about the whole \"fraction of UMIs of a gene in a cell\" concept, which is that it is highly dependent on the set of genes you pick to compute the fraction out of (that is, the denominator). This places restrictions on how you should use these fractions:\n\nYou can't just compare these fractions between two arbitrary data sets, as the denominators aren't the same. You must identify the set of common genes, and renormalize the fractions to sum to one in this subset, in both data sets. Only then can you meaningfully compare the results.\nEven if you compare two data sets with the same set of genes (or even two subsets of the same data set, such as two \"cell types\"), if a specific \"gene program\" has a very high total expression in only one of them, then all other genes will artificially appear to be lower.\nThis is why we recommend excluding ribosomal genes from the data sets; they can take up anything between almost none to over two thirds of the total UMIs, and this varies between \"cell types\". This means that if they are included in the denominator, the fractions of otherwise \"identical\" genes will appear to differ by a factor of up to 3X\nLuckily, most gene programs we deal with have a total expression of a few percent at most, so this effect is negligible. However if you identify a gene program with a total expression higher than, say, 10%, you should consider its effect on the rest of the genes.\n\nInputs\n\nAxes\n\ncell (required): Sequenced single cells.\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ is_excluded::Bool (required): A mask of genes that are excluded from consideration.\n\ncell @ total_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs of all the non-excluded genes in each cell.\n\ncell @ metacell::AbstractString (required): The unique metacell each cell belongs to.\n\nMatrices\n\ngene, cell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of UMIs collected for each gene for each cell.\n\nOutputs\n\nMatrices\n\ngene, metacell @ geomean_fraction::Union{Float32, Float64} (guaranteed): The geomean fraction of the UMIs of each gene in each metacell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_log_geomean_fractions!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_log_geomean_fractions!","text":"function compute_metacells_genes_log_geomean_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe log base 2 of the estimated geomean fraction of the UMIs of each gene in each metacell. This adds the gene_fraction_regularization to deal with zero fractions.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nMatrices\n\ngene, metacell @ geomean_fraction::Union{Float32, Float64} (required): The geomean fraction of the UMIs of each gene in each metacell.\n\nOutputs\n\nMatrices\n\ngene, metacell @ loggeomeanfraction::Union{Float32, Float64} (guaranteed): The log base 2 of the geomean fraction of the UMIs of each gene in each metacell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Types","page":"Analyze Metacells","title":"Types","text":"","category":"section"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_cells_types_by_metacells!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_cells_types_by_metacells!","text":"function compute_cells_types_by_metacells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe type of each cell, based on the type of the metacell it belongs to.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\ncell (required): Sequenced single cells.\n\nVectors\n\ncell @ metacell::AbstractString (required): The unique metacell each cell belongs to.\n\nmetacell @ type::AbstractString (required): The type each metacell belongs to.\n\nOutputs\n\nVectors\n\ncell @ type::AbstractString (guaranteed): The type each cell belongs to.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_types_by_cells!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_types_by_cells!","text":"function compute_metacells_types_by_cells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe type of each metacell, based on is cell types. This assumes that each cell was assigned type, either because we imported the data from a cell-based atlas, or from previous computed metacells.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\ncell (required): Sequenced single cells.\n\nVectors\n\ncell @ metacell::AbstractString (required): The unique metacell each cell belongs to.\n\ncell @ type::AbstractString (required): The type each cell belongs to.\n\nOutputs\n\nVectors\n\nmetacell @ type::AbstractString (guaranteed): The type each metacell belongs to.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Distances","page":"Analyze Metacells","title":"Distances","text":"","category":"section"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_euclidean_distances!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_euclidean_distances!","text":"function compute_metacells_euclidean_distances!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe Euclidean distance between the log of the covered fraction of the skeleton genes between the metacells.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ is_skeleton::Bool (required): A mask of genes that are used to predict the values of the rest of the (covered) genes.\n\nMatrices\n\nmetacell, gene @ logcoveredfraction::Union{Float32, Float64} (required): The log base 2 of the linear fraction of the UMIs of each covered gene in each metacell, out of the total covered UMIs.\n\nOutputs\n\nMatrices\n\nmetacell, metacell @ euclideanskeletondistance::Union{Float32, Float64} (guaranteed): The Euclidean distance between the log of the covered fraction of the skeleton genes between the metacells.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_max_skeleton_fold_distances!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_max_skeleton_fold_distances!","text":"function compute_metacells_max_skeleton_fold_distances!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    min_significant_gene_UMIs::Integer = ```40```,\n    fold_confidence::AbstractFloat = ```0.9```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe maximal significant fold factor between the covered fraction of skeleton genes between the metacells. This uses heuristics to require the fold factor be based on a sufficient number of UMIs to be robust.\n\nThe fold factor is log (base 2) of the gene expression using the gene_fraction_regularization. For computing this fold factor, we ignore \"insignificant\" genes whose total UMIs in the compared metacells isn't at least min_significant_gene_UMIs. We also we reduce the distance using the fold_confidence based on the number of UMIs used to estimate the expression in the metacells.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ is_skeleton::Bool (required): A mask of genes that are used to predict the values of the rest of the (covered) genes.\n\nmetacell @ covered_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of the covered genes in each metacell.\n\nMatrices\n\ngene, metacell @ covered_fraction::Union{Float32, Float64} (required): The linear fraction of the UMIs of each covered gene in each metacell, out of the total covered UMIs.\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs of each gene in the cells of each metacell.\n\nOutputs\n\nMatrices\n\nmetacell, metacell @ maxskeletonfold_distance::Union{Float32, Float64} (guaranteed): The maximal significant fold factor between the covered fraction of skeleton genes between the metacells.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Index","page":"Analyze Metacells","title":"Index","text":"","category":"section"},{"location":"analyze_metacells.html","page":"Analyze Metacells","title":"Analyze Metacells","text":"Pages = [\"analyze_metacells.md\"]","category":"page"},{"location":"analyze_blocks.html#Analyze-Blocks","page":"Analyze Blocks","title":"Analyze Blocks","text":"","category":"section"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks","text":"Do simple blocks analysis.\n\n\n\n\n\n","category":"module"},{"location":"analyze_blocks.html#Counts","page":"Analyze Blocks","title":"Counts","text":"","category":"section"},{"location":"analyze_blocks.html#Cells","page":"Analyze Blocks","title":"Cells","text":"","category":"section"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_n_cells!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_n_cells!","text":"function compute_blocks_n_cells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of cells per block.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nVectors\n\nmetacell @ n_cells::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of cells in each metacell.\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nOutputs\n\nVectors\n\nblock @ n_cells::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The number of cells in the metacells in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_n_neighborhood_cells!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_n_neighborhood_cells!","text":"function compute_blocks_n_neighborhood_cells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of cells in the metacells of the blocks of the neighborhood centered at a block.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nVectors\n\nmetacell @ n_cells::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of cells in each metacell.\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\nblock, block @ isinneighborhood::Bool (required): For each block, the (column) mask of nearby blocks in its immediate neighborhood.\n\nOutputs\n\nVectors\n\nblock @ nneighborhoodcells::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of cells in the metacells in the blocks of the neighborhood centered at each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_n_environment_cells!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_n_environment_cells!","text":"function compute_blocks_n_environment_cells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of cells in the metacells of the blocks of the environment centered at each block.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nVectors\n\nmetacell @ n_cells::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of cells in each metacell.\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\nblock, block @ isinenvironment::Bool (required): For each block, the (column) mask of nearby blocks in its expanded environment.\n\nOutputs\n\nVectors\n\nblock @ nenvironmentcells::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of cells in the metacells in the blocks of the environment centered at each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells","page":"Analyze Blocks","title":"Metacells","text":"","category":"section"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_n_metacells!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_n_metacells!","text":"function compute_blocks_n_metacells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of metacells per block.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nVectors\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nOutputs\n\nVectors\n\nblock @ n_metacells::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The number of metacells in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_n_neighborhood_metacells!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_n_neighborhood_metacells!","text":"function compute_blocks_n_neighborhood_metacells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of metacells in the blocks of the neighborhood centered at each block.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nVectors\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\nblock, block @ isinneighborhood::Bool (required): For each block, the (column) mask of nearby blocks in its immediate neighborhood.\n\nOutputs\n\nVectors\n\nblock @ nneighborhoodmetacells::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of metacells in the blocks of the neighborhood centered at each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_n_environment_metacells!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_n_environment_metacells!","text":"function compute_blocks_n_environment_metacells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of metacells in the blocks of the environment centered at each block.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nVectors\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\nblock, block @ isinenvironment::Bool (required): For each block, the (column) mask of nearby blocks in its expanded environment.\n\nOutputs\n\nVectors\n\nblock @ nenvironmentmetacells::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of metacells in the blocks of the environment centered at each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Blocks","page":"Analyze Blocks","title":"Blocks","text":"","category":"section"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_n_neighborhood_blocks!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_n_neighborhood_blocks!","text":"function compute_blocks_n_neighborhood_blocks!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of blocks in the neighborhood centered at each block.\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nMatrices\n\nblock, block @ isinneighborhood::Bool (required): For each block, the (column) mask of nearby blocks in its immediate neighborhood.\n\nOutputs\n\nVectors\n\nblock @ nneighborhoodblocks::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of blocks in the neighborhood centered at each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_n_environment_blocks!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_n_environment_blocks!","text":"function compute_blocks_n_environment_blocks!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of blocks in the environment centered at each block.\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nMatrices\n\nblock, block @ isinenvironment::Bool (required): For each block, the (column) mask of nearby blocks in its expanded environment.\n\nOutputs\n\nVectors\n\nblock @ nenvironmentblocks::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of blocks in the environment centered at each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#UMIs","page":"Analyze Blocks","title":"UMIs","text":"","category":"section"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_genes_UMIs!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_genes_UMIs!","text":"function compute_blocks_genes_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of UMIs used to estimate the fraction of each gene in each block. This can used to estimate the robustness of the fraction.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nVectors\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs of each gene in the cells of each metacell.\n\nOutputs\n\nMatrices\n\ngene, block @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of UMIs of each gene in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_total_UMIs!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_total_UMIs!","text":"function compute_blocks_total_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total UMIs of genes per block.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nMatrices\n\ngene, block @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs of each gene in each block.\n\nOutputs\n\nVectors\n\nblock @ total_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of UMIs of all the non-excluded genes in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_covered_UMIs!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_covered_UMIs!","text":"function compute_blocks_covered_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total UMIs of covered genes per block.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the model(s).\n\nMatrices\n\ngene, block @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs of each gene in each block.\n\nOutputs\n\nVectors\n\nblock @ covered_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of the all covered genes in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Fractions","page":"Analyze Blocks","title":"Fractions","text":"","category":"section"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_genes_linear_fractions!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_genes_linear_fractions!","text":"function compute_blocks_genes_linear_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nAn estimated linear fraction of the UMIs of each gene in each block. This is just the total UMIs of the gene in the metacell divided by the total UMIs of the metacell, which is the \"best\" estimate assuming multinomial sampling noise. However, this is sensitive to a few metacells with very high expression levels (\"bursty\" genes).\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nVectors\n\ngene @ is_excluded::Bool (required): A mask of genes that are excluded from consideration.\n\nMatrices\n\ngene, block @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs of each gene in each block.\n\nOutputs\n\nMatrices\n\ngene, block @ linear_fraction::Union{Float32, Float64} (guaranteed): The linear fraction of the UMIs of each non-excluded gene out of the total UMIs in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_genes_log_linear_fractions!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_genes_log_linear_fractions!","text":"function compute_blocks_genes_log_linear_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe log base 2 of the estimated linear fraction of the UMIs of each gene in each block. This adds the gene_fraction_regularization to deal with zero fractions.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nMatrices\n\ngene, block @ linear_fraction::Union{Float32, Float64} (required): The linear fraction of the UMIs of each non-excluded gene out of the total UMIs in each block.\n\nOutputs\n\nMatrices\n\ngene, block @ loglinearfraction::Union{Float32, Float64} (guaranteed): The log base 2 of the linear fraction of the UMIs of each non-excluded gene out of the total UMIs in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_genes_covered_fractions!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_genes_covered_fractions!","text":"function compute_blocks_genes_covered_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nAn estimated linear fraction of the UMIs of each covered gene in each block. By considering only the covered genes this avoid the impact of highly-expressed lateral genes (e.g., cell cycle). Otherwise is similar to compute_blocks_genes_linear_fractions!.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the model(s).\n\nMatrices\n\ngene, block @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs of each gene in each block.\n\nOutputs\n\nMatrices\n\ngene, block @ covered_fraction::Union{Float32, Float64} (guaranteed): The linear fraction of the UMIs of each non-excluded gene out of the total UMIs in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_genes_log_covered_fractions!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_genes_log_covered_fractions!","text":"function compute_blocks_genes_log_covered_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe log base 2 of the estimated linear fraction of the UMIs of each covered gene in each block. This adds the gene_fraction_regularization to deal with zero fractions.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nMatrices\n\ngene, block @ covered_fraction::Union{Float32, Float64} (required): The linear fraction of the UMIs of each non-excluded gene out of the total UMIs in each block.\n\nOutputs\n\nMatrices\n\ngene, block @ logcoveredfraction::Union{Float32, Float64} (guaranteed): The log base 2 of the linear fraction of the UMIs of each covered gene out of the total UMIs in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Genes","page":"Analyze Blocks","title":"Genes","text":"","category":"section"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_genes_is_environment_markers!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_genes_is_environment_markers!","text":"compute_blocks_genes_is_environment_markers!(\n    daf::DafWriter;\n    min_marker_gene_max_fraction::AbstractFloat = ```0.0001```,\n    min_marker_gene_range_fold::Real = ```2```,\n    overwrite::Bool = false,\n)::Nothing\n\nA mask of genes that distinguish between cell states in each environment. Otherwise similar to identify_marker_genes!.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metadata","page":"Analyze Blocks","title":"Metadata","text":"","category":"section"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_types!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_types!","text":"function compute_blocks_types!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe type of each block, based on is metacell types.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nVectors\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nmetacell @ type::AbstractString (required): The type each metacell belongs to.\n\nOutputs\n\nVectors\n\nblock @ type::AbstractString (guaranteed): The type each block belongs to.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Distances","page":"Analyze Blocks","title":"Distances","text":"","category":"section"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_mean_euclidean_distances!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_mean_euclidean_distances!","text":"compute_blocks_mean_euclidean_distances!(\n    daf::DafWriter;\n    overwrite::Bool = false,\n)::Nothing\n\nThe mean Euclidean skeleton genes covered fractions distance between the metacells of the blocks.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_max_skeleton_fold_distances!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_max_skeleton_fold_distances!","text":"compute_blocks_max_skeleton_fold_distances!(\n    daf::DafWriter;\n    overwrite::Bool = false,\n)::Nothing\n\nThe maximal significant skeleton genes covered fractions fold factor between metacells of the blocks.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Index","page":"Analyze Blocks","title":"Index","text":"","category":"section"},{"location":"analyze_blocks.html","page":"Analyze Blocks","title":"Analyze Blocks","text":"Pages = [\"analyze_blocks.md\"]","category":"page"},{"location":"analyze_modules.html#Analyze-Modules","page":"Analyze Modules","title":"Analyze Modules","text":"","category":"section"},{"location":"analyze_modules.html#Metacells.AnalyzeModules","page":"Analyze Modules","title":"Metacells.AnalyzeModules","text":"Do simple gene module analysis.\n\n\n\n\n\n","category":"module"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_blocks_modules_is_strong!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_blocks_modules_is_strong!","text":"function compute_blocks_modules_is_strong!(\n    daf::DafWriter;\n    min_downsamples::Integer = ```750```,\n    min_downsamples_quantile::AbstractFloat = ```0.05```,\n    max_downsamples_quantile::AbstractFloat = ```0.5```,\n    min_strong_UMIs::Integer = 8,\n    min_strong_cells::Integer = ```12```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nA mask of the strong modules that have enough UMIs in enough cells. Enough UMIs means that, if we downsample the cells to a common total covered UMIs using downsamples with the min_downsamples, min_downsamples_quantile, max_downsamples_quantile, the expected total UMIs of the module will be at least min_strong_UMIs. Enough cells mean that this will happen in at least min_strong_cells in the environment. Modules which achieve this are marked as strong enough to be meaningfully applicable to single cells.\n\nInputs\n\nAxes\n\ncell (required): Sequenced single cells.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\ngene (required): Sequenced genes.\n\nmodule (required): Groups of genes that together predict the rest of the covered genes.\n\nVectors\n\ncell @ metacell::AbstractString (required): The unique metacell each cell belongs to.\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\ncell @ covered_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs of all the covered genes in each cell.\n\nMatrices\n\nblock, block @ isinenvironment::Bool (required): For each block, the (column) mask of nearby blocks in its expanded environment.\n\ngene, cell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of UMIs collected for each gene for each cell.\n\nblock, gene @ module::AbstractString (required): The module each gene belongs to in each block.\n\nblock, module @ is_found::Bool (required): A mask of the modules that were found for each block.\n\nOutputs\n\nMatrices\n\nblock, module @ is_strong::Bool (guaranteed): A mask of the modules that have enough UMIs in enough cells.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_blocks_modules_n_genes!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_blocks_modules_n_genes!","text":"function compute_blocks_modules_n_genes!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe number of genes in each gene module in each block.\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nmodule (required): Groups of genes that together predict the rest of the covered genes.\n\ngene (required): Sequenced genes.\n\nMatrices\n\nblock, gene @ module::AbstractString (required): The module each gene belongs to in each block.\n\nOutputs\n\nMatrices\n\nblock, module @ n_genes::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The number of genes in each gene module in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_blocks_modules_n_skeletons!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_blocks_modules_n_skeletons!","text":"function compute_blocks_modules_n_skeletons!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe number of skeleton genes in each gene module in each block.\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" cell state.\n\nmodule (required): Groups of genes that together predict the rest of the covered genes.\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ is_skeleton::Bool (required): A mask of genes that are used to predict the values of the rest of the (covered) genes.\n\nMatrices\n\nblock, gene @ module::AbstractString (required): The module each gene belongs to in each block.\n\nOutputs\n\nMatrices\n\nblock, module @ n_skeletons::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The number of skeleton genes in each gene module in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_block_metacell_module_environment_total_UMIs!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_block_metacell_module_environment_total_UMIs!","text":"compute_block_metacell_module_environment_total_UMIs!(daf::DafWriter; overwrite::Bool = false)::Nothing\n\nThe total UMIs of each environment module in each environment metacell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_block_metacell_module_environment_linear_fractions!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_block_metacell_module_environment_linear_fractions!","text":"compute_block_metacell_module_environment_linear_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```\n)::Nothing\n\nThe linear fraction of the total UMIs of each environment module in each environment metacell, out of the total UMIs.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_block_metacell_module_environment_log_linear_fractions!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_block_metacell_module_environment_log_linear_fractions!","text":"compute_block_metacell_module_environment_log_linear_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe log base 2 of the linear fraction of the total UMIs of each environment module in each environment metacell, out of the total UMIs.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_block_metacell_module_environment_covered_fractions!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_block_metacell_module_environment_covered_fractions!","text":"compute_block_metacell_module_environment_covered_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe linear fraction of the total UMIs of each environment module in each environment metacell, out of the total covered UMIs.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_block_metacell_module_environment_log_covered_fractions!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_block_metacell_module_environment_log_covered_fractions!","text":"compute_block_metacell_module_environment_log_covered_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe log base 2 of the linear fraction of the total UMIs of each environment module in each environment metacell, out of the total covered UMIs.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Index","page":"Analyze Modules","title":"Index","text":"","category":"section"},{"location":"analyze_modules.html","page":"Analyze Modules","title":"Analyze Modules","text":"Pages = [\"analyze_modules.md\"]","category":"page"},{"location":"index.html#Metacells","page":"Metacells","title":"Metacells","text":"","category":"section"},{"location":"index.html#Metacells.Metacells","page":"Metacells","title":"Metacells.Metacells","text":"The Metacells.jl package provides computational services for the metacells package, using Daf to hold the data. In the future, we'll ideally migrate all of the metacellspackage computations to this package, converting the Python package to a thin wrapper, and provide a similar thin R wrapper to provide metacell analysis from R as well. For now,Metacells.jlonly provides a subset of the features of the Pythonmetacellspackage, which requires users to convert data fromAnnData(for the old features) to Daf (to the new features).\n\n\n\n\n\n","category":"module"},{"location":"index.html#Index","page":"Metacells","title":"Index","text":"","category":"section"},{"location":"index.html","page":"Metacells","title":"Metacells","text":"","category":"page"}]
}
