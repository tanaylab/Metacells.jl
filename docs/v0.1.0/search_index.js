var documenterSearchIndex = {"docs":
[{"location":"identify_genes.html#Identify-Genes","page":"Identify Genes","title":"Identify Genes","text":"","category":"section"},{"location":"identify_genes.html","page":"Identify Genes","title":"Identify Genes","text":"Metacells.IdentifyGenes\nMetacells.IdentifyGenes.identify_marker_genes!\nMetacells.IdentifyGenes.identify_lonely_genes!","category":"page"},{"location":"identify_genes.html#Metacells.IdentifyGenes","page":"Identify Genes","title":"Metacells.IdentifyGenes","text":"Identify special genes.\n\n\n\n\n\n","category":"module"},{"location":"identify_genes.html#Metacells.IdentifyGenes.identify_marker_genes!","page":"Identify Genes","title":"Metacells.IdentifyGenes.identify_marker_genes!","text":"function identify_marker_genes!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = 1e-5,\n    min_gene_range_fold::AbstractFloat = 2.0,\n    noisy_gene_fold::AbstractFloat = 1.0,\n    min_max_marker_gene_fraction::AbstractFloat = 1e-4,\n    overwrite::Bool = false,\n)::Nothing\n\nIdentify the genes that distinguish at least one metacell from the rest. Such genes are called \"marker\" genes as they (potentially) mark specific cell states. If overwrite, will overwrite an existing is_marker mask.\n\nCompute the minimal and maximal expression level of each gene.\nSelect the genes whose fold factor (log2 of maximal over minimal value, using the gene_fraction_regularization is at least min_marker_gene_range_fold. For is_noisy genes, we require an additional noisy_gene_fold.\nIdentify the genes whose maximal expression is at least min_max_marker_gene_fraction.\n\nCONTRACT\n\n\n\n\n\n","category":"function"},{"location":"identify_genes.html#Metacells.IdentifyGenes.identify_lonely_genes!","page":"Identify Genes","title":"Metacells.IdentifyGenes.identify_lonely_genes!","text":"function identify_lonely_genes!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = 1e-5,\n    max_lonely_gene_correlation::AbstractFloat = 0.5,\n    max_lonely_gene_correlated::Integer = 2,\n    overwrite::Bool = false,\n)::Nothing\n\nIdentify genes that are uncorrelated with other genes. Such \"lonely\" genes make it difficult to identify groups of genes that act together. If overwrite, will overwrite an existing is_lonely mask.\n\nCompute the log base 2 of the genes expression in each metacell (using the gene_fraction_regularization).\nCorrelate this between all the pairs of genes.\nFind the maximal correlation for each gene.\nIdentify the genes which have up to max_lonely_gene_correlated genes with a correlation of more than max_lonely_gene_correlation.\n\nCONTRACT\n\n\n\n\n\n","category":"function"},{"location":"identify_genes.html#Index","page":"Identify Genes","title":"Index","text":"","category":"section"},{"location":"identify_genes.html","page":"Identify Genes","title":"Identify Genes","text":"Pages = [\"identify_genes.md\"]","category":"page"},{"location":"anndata_format.html#AnnData-Format","page":"AnnData Format","title":"AnnData Format","text":"","category":"section"},{"location":"anndata_format.html","page":"AnnData Format","title":"AnnData Format","text":"Metacells.AnnDataFormat\nMetacells.AnnDataFormat.import_h5ads!\nMetacells.AnnDataFormat.CopyAnnData","category":"page"},{"location":"anndata_format.html#Metacells.AnnDataFormat","page":"AnnData Format","title":"Metacells.AnnDataFormat","text":"Import and export metacells data from/to h5ad files. This allows moving data between the old Python/C++ based AnnData world and the new Julia based Daf world.\n\n\n\n\n\n","category":"module"},{"location":"anndata_format.html#Metacells.AnnDataFormat.import_h5ads!","page":"AnnData Format","title":"Metacells.AnnDataFormat.import_h5ads!","text":"function import_h5ads!(\n    destination::DafWriter;\n    raw_cells_h5ad::Maybe{AbstractString} = nothing,\n    clean_cells_h5ad::AbstractString,\n    metacells_h5ad::AbstractString,\n    copy_clean_data::Maybe{CopyAnnData} = nothing,\n    type_property::Maybe{AbstractString} = nothing,\n    rename_type::Maybe{AbstractString} = \"type\",\n    type_colors_csv::Maybe{AbstractString} = nothing,\n    type_properties::Maybe{AbstractStringSet} = nothing,\n    properties_defaults::Maybe{Dict} = nothing,\n)::Nothing\n\nImport an AnnData based metacells dataset into a Daf destination data set. Ideally, the input must include clean_cells_h5ad and the metacells_h5ad computed for them, and optionally also the raw_cells_h5ad including the excluded cells and genes.\n\nIf type annotations were assigned to the metacells, then the name of the type_property should be specified. This can be further enhanced by specifying a type_colors_csv file mapping type names to colors. This should be a comma or tab separated file containing at least two columns, one named \"color\" and one with the same name as the type_property. For consistency, by default the type_property is renamed to the value of rename_type (by default, \"type\"). You can disable this by setting rename_type to nothing. We also call reconstruct_axis! to build the type axis; you can therefore specify an empty_type name, which will be converted to the empty string, to match the Daf convention of \"no value\" for string data, and specify an explicit set of type_properties (by default, any per-metacell property that has the same value for all metacells of each type will be converted to a type property) and properties_defaults.\n\nThis will mostly just read all the specified h5ad files and copy the data into the destination, with the following changes to match the Daf capabilities and conventions:\n\nThe X matrix of the cells is renamed to UMIs, and the X matrix of the metacells is renamed to fraction.\nMatrices and vectors of counts (UMIs, zeros) or module indices are converted to an unsigned type.\nThe __name__ scalar is not copied.\nThe excluded_gene and excluded_cell masks are not copied. Instead, if raw_cells_h5ad is specified, an is_excluded mask is created for both cells and genes, marking these that exist only in the raw_cells_h5ad and not in clean_cells_h5ad and metacells_h5ad.\nThe full_gene_index is not copied.\nThe properly_sampled_gene mask is renamed to the per-gene is_properly_sampled mask.\nThe bursty_lonely_gene mask is renamed to the per-gene is_bursty_lonely mask.\nThe lateral_gene mask is renamed to the per-gene is_lateral mask.\nThe noisy_gene mask is renamed to the per-gene is_noisy mask.\nThe rare_gene mask is renamed to the per-gene is_rare mask.\nThe rare_gene_module has 1 added to it (that is, \"no module\" is 0 in Daf) and is renamed to rare_module.\nThe lateral_genes_module has 1 added to it (that is, \"no module\" is 0 in Daf) and is renamed to lateral_module.\nThe marker_gene mask is renamed to the per-gene is_marker mask.\nThe selected_gene mask is renamed to the per-gene is_selected mask.\nThe ignored_gene mask is renamed to the per-gene is_ignored mask.\nThe ignored_gene_of_<type> masks are converted to an is_ignored mask per-gene-per-type.\nThe projected_noisy_gene mask is renamed to the per-gene is_projected_noisy mask.\nThe atlas_gene, atlas_lateral_gene, atlas_noisy_gene, atlas_marker_gene masks are renamed to the is_atlas, is_atlas_lateral, is_atlas_noisy and is_atlas_marker per-gene masks.\nThe essential_gene_of_<type> masks are converted to an is_essential mask per-gene-per-type.\nThe atlas_essential_gene_of_<type> masks are converted to an is_atlas_essential mask per-gene-per-type.\nThe fitted_gene_of_<type> masks are converted to an is_fitted mask per-gene-per-type.\nThe fitted mask per-gene-per-metacell is renamed to is_fitted.\nThe misfit mask per-gene-per-metacell is renamed to is_misfit.\nThe essential mask per-gene-per-metacell is renamed to is_essential.\nThe full_cell_index is not copied.\nThe properly_sampled_cell mask is renamed to the per-cell is_properly_sampled mask.\nThe rare_cell mask is renamed to the per-cell is_rare mask.\nThe cells_rare_gene_module has 1 added to it (that is, \"no module\" is 0 in Daf) and is renamed to rare_gene_module.\nThe per-cell dissolve mask is renamed to is_dissolved.\nThe per-cell metacell integer annotation is not copied, and the metacell_name string annotation is renamed to metacell.\nThe per-cell most_similar integer annotation is not copied, and the most_similar_name string annotation is renamed to metacell.most_similar.\nThe rare_metacell mask is renamed to the per-metacell is_rare mask.\nThe per-metacell metacells_level is renamed to level.\nThe per-metacell similar mask is renamed to is_similar.\n\nnote: Note\nThere is much duplication of data between the three h5ad files (in particular, per-gene data). Data in raw_cells_h5ad will override data in clean_cells_h5ad, which will override data in metacells_h5ad.\n\nData that exists only in clean_cells_h5ad poses a question when being copied into the full data set, which includes the full raw set of cells and genes. If copy_clean_data is nothing (the default), this is simply an error. Otherwise, data that is listed in copy_clean_data is copied using the specified name and the default value is applied to the raw-only genes or cells.\n\nnote: Note\nIt is common to call reconstruct_axis! on the result (e.g., if the cells were collected from a set of batches).\n\n\n\n\n\n","category":"function"},{"location":"anndata_format.html#Metacells.AnnDataFormat.CopyAnnData","page":"AnnData Format","title":"Metacells.AnnDataFormat.CopyAnnData","text":"Specify how to copy data from AnnData to Daf. The key is simply a vector or matrix name (ignoring axes), and the value is either nothing to ignore the data, or a tuple with the name of the destination Daf property and an optional value to use for missing entries (raw-only cells and/or genes).\n\n\n\n\n\n","category":"type"},{"location":"anndata_format.html#Index","page":"AnnData Format","title":"Index","text":"","category":"section"},{"location":"anndata_format.html","page":"AnnData Format","title":"AnnData Format","text":"Pages = [\"anndata_format.md\"]","category":"page"},{"location":"spheres.html#Spheres","page":"Spheres","title":"Spheres","text":"","category":"section"},{"location":"spheres.html","page":"Spheres","title":"Spheres","text":"Metacells.Spheres\nMetacells.Spheres.compute_improved_spheres!\nMetacells.Spheres.compute_spheres!\nMetacells.Spheres.improve_spheres!","category":"page"},{"location":"spheres.html#Metacells.Spheres","page":"Spheres","title":"Metacells.Spheres","text":"Given a set of raw metacells, partition them into spheres such that all metacells in the same sphere are within some (fold factor) radius of each other. The centroids of these spheres can serve as a representation of the cell state manifold which is less sensitive to oversampling of common cell states. Group these spheres in overlapping neighborhoods of \"similar\" spheres for further analysis.\n\n\n\n\n\n","category":"module"},{"location":"spheres.html#Metacells.Spheres.compute_improved_spheres!","page":"Spheres","title":"Metacells.Spheres.compute_improved_spheres!","text":"function compute_improved_spheres!(\n    daf::DafWriter;\n    min_significant_gene_UMIs::Integer = 40,\n    gene_fraction_regularization::AbstractFloat = 1e-5,\n    confidence::AbstractFloat = 0.9,\n    max_sphere_diameter::AbstractFloat = 2.0,\n    max_neighborhood_diameter::AbstractFloat = 2.0,\n    noisy_gene_fold::AbstractFloat = 1.0,\n    min_gene_correlation::AbstractFloat = 0.5,\n)::Nothing\n\nPartition raw metacells into distinct spheres, and spheres into overlapping neighborhoods, such that each sphere is homogeneous in the genes that participate in multi-gene behaviors in its main neighborhood.\n\nThis calls compute_spheres! and then `improve_spheres!. In the 1st call to compute_spheres! call, we allow up to max_deviant_genes_fraction of the genes to be deviant; in improve_spheres!, we forbid all genes from being deviant, as we expect to ignore all \"irrelevant\" genes as non-markers or lonely.\n\nCONTRACT\n\n\n\n\n\n","category":"function"},{"location":"spheres.html#Metacells.Spheres.compute_spheres!","page":"Spheres","title":"Metacells.Spheres.compute_spheres!","text":"function compute_spheres!(\n    daf::DafWriter;\n    min_significant_gene_UMIs::Integer = 40,\n    gene_fraction_regularization::AbstractFloat = 1e-5,\n    confidence::AbstractFloat = 0.9,\n    max_sphere_diameter::AbstractFloat = 2.0,\n    max_neighborhood_diameter::AbstractFloat = 2.0,\n    noisy_gene_fold::AbstractFloat = 1.0,\n    max_deviant_genes::Integer = 0,\n    overwrite::Bool = false,\n)::Nothing\n\nPartition raw metacells into distinct spheres, and spheres into overlapping neighborhoods.\n\nnote: Note\nThis is a lower-level function; you probably want to call compute_improved_spheres! instead.\n\nCompute a distance between each two metacells, defined as the maximal fold factor of any of the genes. This fold factor is the absolute value of the difference in the log base 2 of the fraction of the gene in both metacells, using the gene_fraction_regularization (by default, 1e-5). Since the fraction of the gene is a random variable, we decrease the high fraction and increase the low fraction by a factor based on the confidence of the test (by default, 0.9), assuming a multinomial distribution. In addition, if the sum of the total UMIs of the gene in both metacells is less than min_significant_gene_UMIs (by default, 40), we ignore this fold factor as insignificant. We also ignore the fold factors for genes that aren't is_marker in the vicinity of at least one of the metacells, or that are is_lonely in the vicinity of both. For is_noisy_gene_fold genes, we reduce the distance by noisy_gene_fold to allow for their bursty nature.\nIf max_deviant_genes is not zero, we redefine the distance between metacells to be the number of genes with a maximal fold distance above the max_sphere_diameter (for computing spheres) and max_neighborhood_diameter (for computing neighborhoods). Otherwise, we use the raw maximal fold distance.\nCompute hierarchical clustering of the metacells using these distances and the complete linkage; that is, each cluster can be seen as a sphere of some diameter where all the metacells are within that sphere.\nUse this hierarchical clustering to partition the metacells into as-large as possible spheres. If max_deviant_genes is zero (the default), then this is cutree using the max_sphere_diameter (by default, 2.0, or 4x); otherwise, it is a cutree using the max_deviant_genes.\nCompute for each sphere the set of other spheres in its main neighborhood. If max_deviant_genes is zero, this means the maximal distance between any pair of metacells is at most an additional max_neighborhood_diameter (by default, 2.0, for a total neighborhood diameter of 16x). Otherwise, it means the maximal number of genes whose distance is more than this threshold in the metacells pair is at most max_deviant_genes. Neighborhoods can overlap; also, if the main neighborhoods defined by two spheres end up being identical, we unify them, so we may end up with less neighborhoods than spheres.\nThe distances to the other spheres in the main neighborhood of each sphere form a natural graph representation of the structure of the manifold of the distinct biological cell states captured by the metacells.\n\nIf overwrite is set, the results will replace any previously computed spheres and neighborhoods.\n\nCONTRACT\n\n\n\n\n\n","category":"function"},{"location":"spheres.html#Metacells.Spheres.improve_spheres!","page":"Spheres","title":"Metacells.Spheres.improve_spheres!","text":"function improve_spheres!(\n    daf::DafWriter;\n    min_significant_gene_UMIs::Integer = 40,\n    gene_fraction_regularization::AbstractFloat = 1e-5,\n    confidence::AbstractFloat = 0.9,\n    max_sphere_diameter::AbstractFloat = 2.0,\n    max_neighborhood_diameter::AbstractFloat = 2.0,\n    noisy_gene_fold::AbstractFloat = 1.0,\n    min_gene_correlation::AbstractFloat = 0.5,\n)::Nothing\n\nImprove the partition raw metacells into distinct spheres, and spheres into overlapping neighborhoods. The improved partition ensures no gene is not \"too different\" between the metacells in each sphere and spheres in each neighborhood; however, this only applies to genes that have at least min_gene_correlation with at least one other gene in the neighborhood.\n\nInvoke identify_marker_genes! and identify_lonely_genes! for each neighborhood and store the results in is_marker and is_lonely of the genes for the metacells in sphere for which this is the main neighborhood.\nRecompute the spheres with max_deviant_genes = 0 and overwrite = true. When computing the distance between each two metacells, this will only consider genes that are markers in either metacell and are not lonely in both. The result should be \"improved\" spheres as they will not be affected by genes that aren't part of some multi-gene behavior relevant to each sphere's neighborhood.\n\nCONTRACT\n\n\n\n\n\n","category":"function"},{"location":"spheres.html#Index","page":"Spheres","title":"Index","text":"","category":"section"},{"location":"spheres.html","page":"Spheres","title":"Spheres","text":"Pages = [\"spheres.md\"]","category":"page"},{"location":"index.html#Metacells","page":"Metacells","title":"Metacells","text":"","category":"section"},{"location":"index.html","page":"Metacells","title":"Metacells","text":"Metacells.Metacells","category":"page"},{"location":"index.html#Metacells.Metacells","page":"Metacells","title":"Metacells.Metacells","text":"The Metacells.jl package provides computational services for the metacells package, using Daf to hold the data. In the future, we'll ideally migrate all of the metacellspackage computations to this package, converting the Python package to a thin wrapper, and provide a similar thin R wrapper to provide metacell analysis from R as well. For now,Metacells.jlonly provides a subset of the features of the Pythonmetacellspackage, which requires users to convert data fromAnnData(for the old features) toDaf (to the new features).\n\n\n\n\n\n","category":"module"},{"location":"index.html#Index","page":"Metacells","title":"Index","text":"","category":"section"},{"location":"index.html","page":"Metacells","title":"Metacells","text":"","category":"page"}]
}
