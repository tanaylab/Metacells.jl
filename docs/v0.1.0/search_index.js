var documenterSearchIndex = {"docs":
[{"location":"defaults.html#Defaults","page":"Defaults","title":"Defaults","text":"","category":"section"},{"location":"defaults.html#Metacells.Defaults","page":"Defaults","title":"Metacells.Defaults","text":"Default values for parameters.\n\n\n\n\n\n","category":"module"},{"location":"defaults.html#Metacells.Defaults.GENE_FRACTION_REGULARIZATION","page":"Defaults","title":"Metacells.Defaults.GENE_FRACTION_REGULARIZATION","text":"When computing log (base 2) of the fraction of the gene expression out of the total, we use this regularization factor by default top avoid zero values.\n\n\n\n\n\n","category":"constant"},{"location":"defaults.html#Metacells.Defaults.MIN_SIGNIFICANT_GENE_UMIS","page":"Defaults","title":"Metacells.Defaults.MIN_SIGNIFICANT_GENE_UMIS","text":"When comparing gene expression levels (e.g., when computing fold factors), we do not consider the result to be significant unless at least this number of UMIs were used to compute the compared value(s).\n\n\n\n\n\n","category":"constant"},{"location":"defaults.html#Index","page":"Defaults","title":"Index","text":"","category":"section"},{"location":"defaults.html","page":"Defaults","title":"Defaults","text":"Pages = [\"defaults.md\"]","category":"page"},{"location":"compute_blocks.html#Compute-Blocks","page":"Compute Blocks","title":"Compute Blocks","text":"","category":"section"},{"location":"compute_blocks.html#Metacells.ComputeBlocks","page":"Compute Blocks","title":"Metacells.ComputeBlocks","text":"Group \"very close\" metacells into disjoint blocks, and blocks into overlapping vicinities, for constructing a local linear approximation to the manifold.\n\n\n\n\n\n","category":"module"},{"location":"compute_blocks.html#Metacells.ComputeBlocks.compute_blocks!","page":"Compute Blocks","title":"Metacells.ComputeBlocks.compute_blocks!","text":"function compute_blocks!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    min_significant_gene_UMIs::Integer = ```40```,\n    fold_confidence::AbstractFloat = ```0.9```,\n    max_block_span::Real = ```2```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nGroup the metacells into blocks where the metacells in each one are \"similar\" in all the skeleton genes. That is, each block is an approximation of a single cell state, assuming the skeleton genes adequately predict the rest of the genes.\n\nFirst, we compute metacell-metacell distances based on the maximal fold factor between is_skeleton genes. The fold factor is log (base 2) of the gene expression using the gene_fraction_regularization. For computing this fold factor, we ignore \"insignificant\" genes whose total UMIs in the compared metacells isn't at least min_significant_gene_UMIs. We also we reduce the distance using the fold_confidence based on the number of UMIs used to estimate the expression in the metacells. Two metacells can only belong to the same block if the final fold factor is at most max_block_span in all the (significant, skeleton) genes.\n\nWe then compute block-block distances which are the maximal distance between the metacells of the blocks.\n\nnote: Note\nThis uses the virtual metacell_gene_covered_fraction_matrix. You will need an adapter to map these to concrete fractions (geomean, linear, scaled, ...).\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ is_skeleton::Bool (required): A mask of genes that are used to predict the values of the rest of the (covered) genes.\n\nmetacell @ covered_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of the covered genes in each metacell.\n\nMatrices\n\ngene, metacell @ covered_fraction::Union{Float32, Float64} (required): Some estimated fraction of the UMIs of each covered gene in each metacell.\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nOutputs\n\nAxes\n\nblock (guaranteed): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\nmetacell @ block::AbstractString (guaranteed): The unique block each metacell belongs to.\n\nMatrices\n\nmetacell, metacell @ maxskeletonfold_distance::Union{Float32, Float64} (guaranteed): The maximal fold factor between skeleton genes between the metacells.\n\nblock, block @ maxskeletonfold_distance::Union{Float32, Float64} (guaranteed): The maximal fold factor between skeleton genes between the metacells of the blocks.\n\n\n\n\n\n","category":"function"},{"location":"compute_blocks.html#Metacells.ComputeBlocks.compute_blocks_is_in_neighborhood!","page":"Compute Blocks","title":"Metacells.ComputeBlocks.compute_blocks_is_in_neighborhood!","text":"function compute_blocks_is_in_neighborhood!(\n    daf::DafWriter;\n    min_blocks_in_neighborhood::Integer = ```4```,\n    min_metacells_in_neighborhood::Integer = ```20```,\n    min_covered_UMIs_in_neighborhood::Integer = ```2000000```,\n    rng::AbstractRNG = default_rng(),\n    overwrite::Bool = ```false```,\n)::Nothing\n\nGroup the blocks into overlapping small tight neighborhoods, and larger environments, such that each block's environment can be reasonably approximated using a local linear model, evaluated using cross-validation on the RMSE in the neighborhood at its core.\n\nUsing the block-block distances, we define a tight neighborhood of each block containing at least min_blocks_in_neighborhood, min_metacells_in_neighborhood and min_covered_UMIs_in_neighborhood (note that the latter only counts UMIs of skeleton genes).\n\nHaving computed the neighborhoods, we expand them (using the same block-block distances) as long as computing a local linear model for the environment gives a better approximation of the metacells in the neighborhood. This local model starts with computing max_principal_components. These are assumed to over-fit the solution, so we use cross-validation (in cross_validation_parts) to pick a subset of these principal components, which hopefully approximates the true dimensionality of the local data.\n\nnote: Note\nThere is no attempt to reconcile the local model of neighboring blocks. In general the linear model computed here isn't very useful for interpreting the data as principal components for noisy high-dimensional data are pretty opaque.\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\nblock @ covered_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of the covered genes in each block.\n\nblock @ n_metacells::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of metacells in each block.\n\nMatrices\n\nblock, block @ maxskeletonfold_distance::Union{Float32, Float64} (required): The maximal fold factor between skeleton genes between the metacells of the blocks.\n\nOutputs\n\nMatrices\n\nblock, block @ isinneighborhood::Bool (guaranteed): For each block, the (column) mask of nearby blocks in its immediate neighborhood.\n\n\n\n\n\n","category":"function"},{"location":"compute_blocks.html#Metacells.ComputeBlocks.compute_blocks_is_in_environment!","page":"Compute Blocks","title":"Metacells.ComputeBlocks.compute_blocks_is_in_environment!","text":"function compute_blocks_is_in_environment!(\n    daf::DafWriter;\n    max_principal_components = ```40```,\n    cross_validation_parts::Integer = ```5```,\n    rng::AbstractRNG = default_rng(),\n    overwrite::Bool = ```false```,\n)::Nothing\n\nExpand the block neighborhoods to larger linear environment. We expand the neighborhood as long as computing a local linear model for the environment gives a better approximation of the metacells in the neighborhood. This local model with computing max_principal_components. These are assumed to over-fit the solution, so we use cross-validation (in cross_validation_parts) to pick a subset of these principal components to actually use, which hopefully approximates the true dimensionality of the local data.\n\nnote: Note\nThis uses the virtual metacell_gene_covered_fraction_matrix. You will need an adapter to map these to concrete fractions (geomean, linear, scaled, ...).\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\ngene @ is_skeleton::Bool (required): A mask of genes that are used to predict the values of the rest of the (covered) genes.\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\ngene, metacell @ covered_fraction::Union{Float32, Float64} (required): Some estimated fraction of the UMIs of each covered gene in each metacell.\n\nblock, block @ isinneighborhood::Bool (required): For each block, the (column) mask of nearby blocks in its immediate neighborhood.\n\nblock, block @ maxskeletonfold_distance::Union{Float32, Float64} (required): The maximal fold factor between skeleton genes between the metacells of the blocks.\n\nOutputs\n\nAxes\n\nprincipal_component (guaranteed): A local (per block) principal component.\n\nVectors\n\nblock @ nusedprincipal_components::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The number of used principal components for each block.\n\nblock @ pca_RMSE::Union{Float32, Float64} (guaranteed): The root mean squared error of predicting the covered genes using the principal components in the vicinity of the block.\n\nblock @ pca_XRMSE::Union{Float32, Float64} (guaranteed): The cross-validated root mean squared error of predicting the covered genes using the principal components in the vicinity of the block.\n\nMatrices\n\nblock, block @ isinenvironment::Bool (guaranteed): For each block, the (column) mask of nearby blocks in its expanded environment.\n\nblock, principalcomponent @ isused::Bool (guaranteed): Whether each principal component is used by each block.\n\nblock, gene @ basecoveredfraction::Union{Float32, Float64} (guaranteed): The base covered fractions used by the principal component analysis..\n\nTensors\n\nblock; principalcomponent, gene @ skeletoncoefficient::Union{Float32, Float64} (guaranteed): The coefficient of each skeleton gene for computing a principle component.\n\nblock; principalcomponent, gene @ coveredcoefficient::Union{Float32, Float64} (guaranteed): The coefficient of each principal component for computing each covered gene.\n\n\n\n\n\n","category":"function"},{"location":"compute_blocks.html#Index","page":"Compute Blocks","title":"Index","text":"","category":"section"},{"location":"compute_blocks.html","page":"Compute Blocks","title":"Compute Blocks","text":"Pages = [\"compute_blocks.md\"]","category":"page"},{"location":"gmara.html#Gmara","page":"Gmara","title":"Gmara","text":"","category":"section"},{"location":"gmara.html#Metacells.Gmara","page":"Gmara","title":"Metacells.Gmara","text":"Access gene names lists from Gmara.\n\nnote: Note\nAll the functions here are thread-safe and can also be invoked from multiple parallel processes using the same CACHE_DIR. This directory can even be shared between multiple users as long as they have read-write permissions to the shared directory. This should even work on NFS mounted volumes shared between multiple servers.\n\n\n\n\n\n","category":"module"},{"location":"gmara.html#Configuration","page":"Gmara","title":"Configuration","text":"","category":"section"},{"location":"gmara.html#Metacells.Gmara.CACHE_DIR","page":"Gmara","title":"Metacells.Gmara.CACHE_DIR","text":"The default ($HOME/.cache/gmara) location of the cache of downloaded Gmara data files.\n\nYou can override this by setting the METACELLS_GMARA_CACHE_DIR environment variable, or by passing an explicit cache_dir parameter to the functions.\n\nThe top-level under this is the version indicator, where main is always the latest and greatest version. Under each version we store the files in the same path as in github, with a .gz suffix for the compressed raw data, .jl_set.gz for serialized Julia set objects, and .lock for temporary lock files for coordinating between parallel processes.\n\n\n\n\n\n","category":"constant"},{"location":"gmara.html#Metacells.Gmara.TIMEOUT","page":"Gmara","title":"Metacells.Gmara.TIMEOUT","text":"The default timeout in seconds (10) for waiting for a lock file in the Gmara cache. If not positive, will wait forever. If a process crashes very badly then a lock file may be left behind and may need to be removed by hand to allow access for the data.\n\nYou can override this by setting the METACELLS_GMARA_TIMEOUT environment variable, or by passing an explicit timeout parameter to the functions.\n\n\n\n\n\n","category":"constant"},{"location":"gmara.html#Functions","page":"Gmara","title":"Functions","text":"","category":"section"},{"location":"gmara.html#Metacells.Gmara.normalize_gene_name","page":"Gmara","title":"Metacells.Gmara.normalize_gene_name","text":"normalize_gene_name(name::AbstractString; namespace::AbstractString)::AbstractString\n\nNormalize the a gene name in some namespace. In most namespaces, this means removing the .[0-9] version suffix from the name, and converting the name to upper case. To lookup a name in a list or a namespace, you need to normalize the query gene name accordingly. The UCSC namespace is an exception in that it is all-lower-case and the .[0-9] suffix seems to be an inherent part of the identifier.\n\n\n\n\n\n","category":"function"},{"location":"gmara.html#Metacells.Gmara.gmara_genes","page":"Gmara","title":"Metacells.Gmara.gmara_genes","text":"gmara_genes(;\n    species::AbstractString,\n    namespace::AbstractString,\n    [list::Maybe{AbstractString} = nothing,\n    version::AbstractString = \"main\"\n    cache_dir = CACHE_DIR,\n    timeout::Real = TIMEOUT],\n)::AbstractSet{<:AbstractString}\n\nReturn the set of names of a version of a list in a namespace of genes of some species. This returns all the names that are (probably) in the list; it a name isn't in the result, it is almost certain it does not belong in the list. As usual in Gmara, this includes everything that may be used as name, e.g. for Ensembl it includes genes, transcripts and proteins; for Symbol it includes approved and alises; etc. If the list is nothing, this just returns the set of known gene names in the namespace.\n\n\n\n\n\n","category":"function"},{"location":"gmara.html#Metacells.Gmara.set_gmara_genes_mask!","page":"Gmara","title":"Metacells.Gmara.set_gmara_genes_mask!","text":"set_gmara_genes_mask!(\n    daf::DafWriter;\n    species::AbstractString,\n    namespace::AbstractString,\n    [list::Maybe{AbstractString} = nothing,\n    gene_names::AbstractString = \"name\",\n    property::Maybe{AbstractString} = nothing,\n    overwrite::Bool = false,\n    cache_dir = CACHE_DIR,\n    timeout::Real = TIMEOUT],\n)::Nothing\n\nSet a gene property mask in daf based on some version of a Gmara list of some namespace for some species. We match the gene_names (by default, just the unique names in the gene axis) with the list names and set the result mask as a per-gene property (by default, is_list). If list is nothing, this just marks the gene names that exist in the namespace. If overwrite, this will overwrite an existing property of the.array same name.\n\n\n\n\n\n","category":"function"},{"location":"gmara.html#Metacells.Gmara.empty_gmara_cache!","page":"Gmara","title":"Metacells.Gmara.empty_gmara_cache!","text":"empty_gmara_cache!()::Nothing\n\nAll requests are cached in-memory. This makes repeated requests cheap. This consumes some (modest amount of) memory; also, if the data in the server has been updated (which rarely happens), you will keep getting the old result. This function releases all the memory and forces all subsequent requests to query the server. In the common case the server tells us our disk cache data is up to date, we don't re-download it).\n\n\n\n\n\n","category":"function"},{"location":"gmara.html#Index","page":"Gmara","title":"Index","text":"","category":"section"},{"location":"gmara.html","page":"Gmara","title":"Gmara","text":"Pages = [\"gmara.md\"]","category":"page"},{"location":"contracts.html#Contracts","page":"Contracts","title":"Contracts","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts","page":"Contracts","title":"Metacells.Contracts","text":"Functions for defining a Contract for a metacells Daf data set @computation. This also serves as a vocabulary describing the data we keep when doing metacells based analysis, which is a solid basis for understanding what is going on. As Fred Brooks said: \"Show me your flowcharts and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won’t usually need your flowcharts; they’ll be obvious.\".\n\nIn the descriptions below, \"fold factor\" refers to the log base 2 of the ratio between expression levels. For fold factors between gene RNA expression levels (fractions), we typically use a regularization factor of 1e-5 to avoid division by zero.\n\n\n\n\n\n","category":"module"},{"location":"contracts.html#Axes","page":"Contracts","title":"Axes","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.gene_axis","page":"Contracts","title":"Metacells.Contracts.gene_axis","text":"gene_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of sequenced genes. By convention we use gene symbols as the namespace of the genes, but this may be different depending on the data set.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_axis","page":"Contracts","title":"Metacells.Contracts.cell_axis","text":"cell_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of sequenced single cells. There's no convention for cell names, as long as they are unique. Typically some sort of barcode is used, possibly combined with a batch and/or plate and/or experiment identification. In the latter case it is recommended that batch and/or plate and/or experiment would also be created as explicit axes, to allow associating metadata with them instead of repeating it for each cell.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_axis","page":"Contracts","title":"Metacells.Contracts.metacell_axis","text":"metacell_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of metacells, which are minimal-sized groups of cells for robust point estimates. Each metacell is considered to be a robustly estimated point in the multi-dimensional manifold of cell states. Metacells may be very similar or very different from each other depending on the data set and the manifold region.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_axis","page":"Contracts","title":"Metacells.Contracts.block_axis","text":"block_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of blocks, which are distinct groups of metacells with \"very close\" estimated cell state. The metacells in each block all have very close estimates of the skeleton gene expressions (maximal fold factor up to some maximal span).\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.type_axis","page":"Contracts","title":"Metacells.Contracts.type_axis","text":"type_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of types, which are distinct named biological cell states. Types are convenient labels manually assigned to large groups of cells, metacells, blocks, neighborhoods, etc. The resolution of the type labels depends on the data set and the type of analysis. In particular, types are not typically associated with a specific biological cell state, but rather with a set of related biological cell states (possibly along a gradient of such states).\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.principal_component_axis","page":"Contracts","title":"Metacells.Contracts.principal_component_axis","text":"principal_component_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of local (per block) principal components. There's no relationship between the same-name/index principal component in different blocks; we just use this axis to be able to create matrices per-block-per-principal-component.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.module_axis","page":"Contracts","title":"Metacells.Contracts.module_axis","text":"module_axis(expectation::ContractExpectation)::Pair{AxisKey, AxisSpecification}\n\nThe axis of local (per block) gene modules. There's no relationship between the same-name/index gene module in different blocks; we just use this axis to be able to create matrices per-block-per-gene-module.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Vectors","page":"Contracts","title":"Vectors","text":"","category":"section"},{"location":"contracts.html#Gene-Vectors","page":"Contracts","title":"Gene Vectors","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.gene_is_excluded_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_excluded_vector","text":"gene_is_excluded_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that are excluded from consideration. These genes are completely unrelated to the biological behaviors of interest. Not only that, they have strong and variable expression levels; enough to have an global impact on the expression level of the rest of the genes - for example, mitochondrial genes. Such genes make it difficult to estimate the relative expression level of genes between different cell states. Therefore, such genes aren't even counted in the total UMIs of each cell. Properties with \"total\" in their name ignore excluded genes, e.g. total_UMIs do not include the UMIs of excluded genes.\n\nThis vector is created in a supervised way based on biological and technical considerations.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_lateral_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_lateral_vector","text":"gene_is_lateral_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that are lateral to the biological behaviors of interest. These genes may satisfy all criteria for being in a group of cooperating genes, but the biological behavior they participate in isn't relevant to the behaviors of interest - for example, genes related to cell cycle or stress. Such genes make it harder to focus on the biological behaviors of interest. They are therefore masked out during the analysis.\n\nThis vector is created in a supervised way based on biological considerations.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_marker_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_marker_vector","text":"gene_is_marker_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that distinguish between cell states. These genes have a significant expression level at some cell state, as well as a significant range of expression across all cell states, so can be used to distinguish between cell states. Non-marker genes are by definition not useful for such analysis, but marker genes aren't necessarily useful due to other considerations.\n\nThis vector is populated by identify_marker_genes!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_marker_rank_vector","page":"Contracts","title":"Metacells.Contracts.gene_marker_rank_vector","text":"gene_marker_rank_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe relative ranks of the marker genes. The more the gene distinguishes between different cell states, the better (lower) rank it has. That is, 1 is for the \"most\" marker gene. Non-marker genes are given an extremely high rank (that maximal the data type allows).\n\nThis vector is populated by rank_marker_genes!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_uncorrelated_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_uncorrelated_vector","text":"gene_is_uncorrelated_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that are not correlated with other gene(s). We typically search for groups of genes that act together. Genes that have no correlation with other genes aren't useful for this sort of analysis, even if they are marker genes.\n\nThis vector is populated by identify_uncorrelated_genes!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_covered_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_covered_vector","text":"gene_is_covered_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that are covered by the local linear programs. When we approximate the manifold using these local linear programs, we only model these genes, ignoring the rest. This allows the approximation to be unaffected by \"irrelevant\" genes. The covered genes are typically some subset of the marker genes of the local region; in particular, they don't include lateral genes. Properties that are computed using only the covered genes contain _covered_ in their name, e.g., linear_covered_fraction vs. linear_fraction.\n\nThis vector is populated by identify_covered_genes!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_skeleton_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_skeleton_vector","text":"gene_is_skeleton_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that are used to predict the values of the rest of the (covered) genes. We assume that knowing the expression level of the skeleton genes is sufficient to reasonably estimate the expression level of the rest of the (covered) genes. For example, if two metacells have \"very close\" expression level of all the skeleton genes, we assume that these metacells are \"very similar\", without looking at the rest of the genes.\n\nThis vector is populated by identify_skeleton_genes!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_is_forbidden_vector","page":"Contracts","title":"Metacells.Contracts.gene_is_forbidden_vector","text":"gene_is_forbidden_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of genes that are forbidden from being used as skeleton factors. When searching for a set of genes that predict the expression of the rest of the genes, we do not consider the forbidden genes.\n\nThis vector is created in a supervised way based on biological considerations.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.gene_divergence_vector","page":"Contracts","title":"Metacells.Contracts.gene_divergence_vector","text":"gene_divergence_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nFor each gene, we scale the fractions of each gene by multiplying with (1 - divergence) of the gene. In particular this is used when considering the distance between gene expressions. When scaling we also renormalize the result so the fractions will sum to one again (for the chosen subset of the genes). Properties that take this scaling into account have scaled in their name, e.g., scaled_linear_fraction vs. linear_fraction.\n\nThis vector is populated by compute_genes_divergence!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Cell-Vectors","page":"Contracts","title":"Cell Vectors","text":"","category":"section"},{"location":"contracts.html#Cell-UMIs-Vectors","page":"Contracts","title":"Cell UMIs Vectors","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.cell_excluded_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.cell_excluded_UMIs_vector","text":"cell_excluded_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of all the excluded genes in each cell.\n\nThis vector is created in a supervised way based on biological considerations.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_total_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.cell_total_UMIs_vector","text":"cell_total_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of all the genes in each cell. This doesn't include the UMIs of genes excluded for any reason.\n\nThis vector is populated by compute_cells_total_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_ribosomal_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.cell_ribosomal_UMIs_vector","text":"cell_ribosomal_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of all the ribosomal genes in each cell.\n\nThis vector is created in a supervised way, typically based on the naming convention that mitochondrial genes names match the pattern ^RP[LS]-.*$.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_mitochondrial_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.cell_mitochondrial_UMIs_vector","text":"cell_mitochondrial_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of all the mitochondrial genes in each cell.\n\nThis vector is created in a supervised way, typically based on the naming convention that mitochondrial genes names match the pattern ^MT-.*$.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_covered_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.cell_covered_UMIs_vector","text":"cell_covered_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of all the covered genes in each cell.\n\nThis vector is populated by compute_cells_covered_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Cell-Metadata-Vectors","page":"Contracts","title":"Cell Metadata Vectors","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.cell_is_excluded_vector","page":"Contracts","title":"Metacells.Contracts.cell_is_excluded_vector","text":"cell_is_excluded_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA mask of cells that are excluded from consideration. This can be due to any number of reasons - doublets, too low a number of UMIs, to high a percentage of excluded gene UMIs, etc. Excluded cells are not grouped into metacells etc., so they are ignored in all properties that sum UMIs per group (e.g., total_UMIs per metacell).\n\nThis vector is created in a supervised way based on biological and technical considerations.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_metacell_vector","page":"Contracts","title":"Metacells.Contracts.cell_metacell_vector","text":"cell_metacell_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe unique metacell each cell belongs to. All the cells in the same metacell are assumed to have \"the same\" (relevant) biological state. This is the empty string if the cell does not belong to any metacell (is excluded or outlier).\n\nThis vector can be populated by any metacells-like algorithm (the original R metacells (1) algorithm, the Python metacells (2) algorithm, other similar algorithms). It can also be populated by sharpen_metacells! which creates a hopefully-improved version of a given grouping into metacells.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_type_vector","page":"Contracts","title":"Metacells.Contracts.cell_type_vector","text":"cell_type_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe type each cell belongs to. This is typically deduced from the type of the metacell the cell belongs to, unless we import the data from an annotated cell atlas.\n\nThis vector can be populated by compute_cells_types_by_metacells! which assigns to each cell the type of the metacell it belongs to.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_linear_metacell_cross_entropy_vector","page":"Contracts","title":"Metacells.Contracts.cell_linear_metacell_cross_entropy_vector","text":"cell_linear_metacell_cross_entropy_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe cross entropy of the gene fractions of a cell given their fractions in the rest of the metacell cells.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_linear_covered_metacell_cross_entropy_vector","page":"Contracts","title":"Metacells.Contracts.cell_linear_covered_metacell_cross_entropy_vector","text":"cell_linear_covered_metacell_cross_entropy_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe cross entropy of the covered gene fractions of a cell given their fractions in the rest of the metacell cells.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_linear_metacell_kl_divergence_vector","page":"Contracts","title":"Metacells.Contracts.cell_linear_metacell_kl_divergence_vector","text":"cell_linear_metacell_kl_divergence_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe KL divergence of the gene fractions of a cell given their fractions in the rest of the metacell cells.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.cell_linear_covered_metacell_kl_divergence_vector","page":"Contracts","title":"Metacells.Contracts.cell_linear_covered_metacell_kl_divergence_vector","text":"cell_linear_covered_metacell_kl_divergence_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe KL divergence of the covered gene fractions of a cell given their fractions in the rest of the metacell cells.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacell-Vectors","page":"Contracts","title":"Metacell Vectors","text":"","category":"section"},{"location":"contracts.html#Metacell-UMIs-Vectors","page":"Contracts","title":"Metacell UMIs Vectors","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_total_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.metacell_total_UMIs_vector","text":"metacell_total_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs used to estimate the fraction of all the genes in each metacell. This is used to estimate the robustness of the gene fraction estimates.\n\nThis vector is populated by compute_metacells_total_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_scaled_total_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.metacell_scaled_total_UMIs_vector","text":"metacell_scaled_total_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs used to estimate the fraction of all the genes in each metacell, scaled by divergence. This is rounded to the nearest UMI.\n\nThis vector is populated by compute_metacells_scaled_total_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_covered_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.metacell_covered_UMIs_vector","text":"metacell_covered_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of the covered genes in each metacell.\n\nThis vector is populated by compute_metacells_covered_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_scaled_covered_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.metacell_scaled_covered_UMIs_vector","text":"metacell_scaled_covered_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of the covered genes in each metacell, scaled by divergence. This is rounded to the nearest UMI.\n\nThis vector is populated by compute_metacells_scaled_covered_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacell-Counts-Vectors","page":"Contracts","title":"Metacell Counts Vectors","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_n_cells_vector","page":"Contracts","title":"Metacells.Contracts.metacell_n_cells_vector","text":"metacell_n_cells_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe number of cells in each metacell.\n\nThis vector is populated by compute_metacells_n_cells!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacell-Metadata-Vectors","page":"Contracts","title":"Metacell Metadata Vectors","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_block_vector","page":"Contracts","title":"Metacells.Contracts.metacell_block_vector","text":"metacell_block_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe unique block each metacell belongs to. All the metacells in the same block are assumed to be \"very close\" to each other, so much so that it is excusable to treat them as \"the same\" cell state.\n\nThis vector is populated by compute_blocks!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_type_vector","page":"Contracts","title":"Metacells.Contracts.metacell_type_vector","text":"metacell_type_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe type each metacell belongs to. This can be assigned in many ways, from manual annotation to using projection methods on an annotated atlas. Often there are multiple type annotations due to different methods. By convention these alternate type vectors are named type.something (e.g., type.projected, type.manual) and the simple type is used for \"the\" type of each metacell.\n\nThis vector is created in a supervised way based on biological considerations.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_mean_cells_linear_cross_entropy_vector","page":"Contracts","title":"Metacells.Contracts.metacell_mean_cells_linear_cross_entropy_vector","text":"metacell_mean_cells_linear_metacell_cross_entropy_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe mean cross entropy of the gene fractions of each metacell cell, given their fractions in the rest of the metacell cells.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_mean_cells_linear_covered_cross_entropy_vector","page":"Contracts","title":"Metacells.Contracts.metacell_mean_cells_linear_covered_cross_entropy_vector","text":"metacell_mean_cells_linear_covered_metacell_cross_entropy_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe mean cross entropy of the covered gene fractions of each metacell cell, given their fractions in the rest of the metacell cells.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_mean_cells_linear_kl_divergence_vector","page":"Contracts","title":"Metacells.Contracts.metacell_mean_cells_linear_kl_divergence_vector","text":"metacell_mean_cells_linear_metacell_kl_divergence_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe mean KL divergence of the gene fractions of each metacell cell, given their fractions in the rest of the metacell cells.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_mean_cells_linear_covered_kl_divergence_vector","page":"Contracts","title":"Metacells.Contracts.metacell_mean_cells_linear_covered_kl_divergence_vector","text":"metacell_mean_cells_linear_covered_metacell_kl_divergence_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe mean KL divergence of the covered gene fractions of each metacell cell, given their fractions in the rest of the metacell cells.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Block-Vectors","page":"Contracts","title":"Block Vectors","text":"","category":"section"},{"location":"contracts.html#Block-UMIs-Vectors","page":"Contracts","title":"Block UMIs Vectors","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_total_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.block_total_UMIs_vector","text":"block_total_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs used to estimate the fraction of all the genes in each block. This is used to estimate the robustness of the gene fraction estimates.\n\nThis vector is populated by compute_blocks_total_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_scaled_total_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.block_scaled_total_UMIs_vector","text":"block_scaled_total_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs used to estimate the fraction of all the genes in each block, scaled by divergence. This is rounded to the nearest UMI.\n\nThis vector is populated by compute_blocks_scaled_total_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_covered_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.block_covered_UMIs_vector","text":"block_covered_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of the covered genes in each block.\n\nThis vector is populated by compute_blocks_covered_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_scaled_covered_UMIs_vector","page":"Contracts","title":"Metacells.Contracts.block_scaled_covered_UMIs_vector","text":"block_scaled_covered_UMIs_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of UMIs of the covered genes in each block, scaled by divergence.\n\nThis vector is populated by compute_blocks_scaled_covered_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Block-Counts-Vectors","page":"Contracts","title":"Block Counts Vectors","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_n_cells_vector","page":"Contracts","title":"Metacells.Contracts.block_n_cells_vector","text":"block_n_cells_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe number of cells in the metacells in each block.\n\nThis vector is populated by compute_blocks_n_cells!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_n_metacells_vector","page":"Contracts","title":"Metacells.Contracts.block_n_metacells_vector","text":"block_n_metacells_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe number of metacells in each block.\n\nThis vector is populated by compute_blocks_n_metacells!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_n_neighborhood_blocks_vector","page":"Contracts","title":"Metacells.Contracts.block_n_neighborhood_blocks_vector","text":"block_n_neighborhood_blocks_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of blocks in the neighborhood centered at each block.\n\nThis vector is populated by compute_blocks_n_neighborhood_blocks!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_n_environment_blocks_vector","page":"Contracts","title":"Metacells.Contracts.block_n_environment_blocks_vector","text":"block_n_environment_blocks_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of blocks in the environment centered at each block.\n\nThis vector is populated by compute_blocks_n_environment_blocks!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_n_neighborhood_metacells_vector","page":"Contracts","title":"Metacells.Contracts.block_n_neighborhood_metacells_vector","text":"block_n_neighborhood_metacells_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of metacells in the blocks of the neighborhood centered at each block.\n\nThis vector is populated by compute_blocks_n_neighborhood_metacells!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_n_environment_metacells_vector","page":"Contracts","title":"Metacells.Contracts.block_n_environment_metacells_vector","text":"block_n_environment_metacells_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of metacells in the blocks of the environment centered at each block.\n\nThis vector is populated by compute_blocks_n_environment_metacells!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_n_neighborhood_cells_vector","page":"Contracts","title":"Metacells.Contracts.block_n_neighborhood_cells_vector","text":"block_n_neighborhood_cells_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of cells in the metacells in the blocks of the neighborhood centered at each block.\n\nThis vector is populated by compute_blocks_n_neighborhood_cells!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_n_environment_cells_vector","page":"Contracts","title":"Metacells.Contracts.block_n_environment_cells_vector","text":"block_n_environment_cells_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe total number of cells in the metacells in the blocks of the environment centered at each block.\n\nThis vector is populated by compute_blocks_n_environment_cells!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Block-Metadata-Vectors","page":"Contracts","title":"Block Metadata Vectors","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_type_vector","page":"Contracts","title":"Metacells.Contracts.block_type_vector","text":"block_type_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe type each block belongs to. This is typically taken to be the most frequent metacell type in the block.\n\nThis vector is populated by compute_blocks_types! based on the metacell types in each block.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Principal-Components-Analysis","page":"Contracts","title":"Principal Components Analysis","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_n_used_principal_components_vector","page":"Contracts","title":"Metacells.Contracts.block_n_used_principal_components_vector","text":"block_n_used_principal_components_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe number of used principal components for each block. We compute a fixed number of principal components for each block, but only actually use a smaller number, different in each block, to avoid overfitting.\n\nThis vector is populated by compute_blocks_is_in_environment!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_pca_RMSE_vector","page":"Contracts","title":"Metacells.Contracts.block_pca_RMSE_vector","text":"block_pca_RMSE_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe root mean squared error of predicting the covered genes using the principal components in the vicinity of the block. Even though we only use some of the principal components, this considers all the metacells, so it is still vulnerable to overfitting.\n\nThis vector is populated by compute_blocks_is_in_environment!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_pca_XRMSE_vector","page":"Contracts","title":"Metacells.Contracts.block_pca_XRMSE_vector","text":"block_pca_XRMSE_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe cross-validated root mean squared error of predicting the covered genes using the principal components in the vicinity of the block. This is similar to the RMSE, but is computed using cross-validation (training the model on a subset of the local metacells, and evaluating it on the rest). This will be higher than the RMSE; the difference is an indicator of the overfitting of the linear model, which should be low relative to the total RMSE.\n\nThis vector is populated by compute_blocks_is_in_environment!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Gene-Modules-Analysis","page":"Contracts","title":"Gene Modules Analysis","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_n_found_modules_vector","page":"Contracts","title":"Metacells.Contracts.block_n_found_modules_vector","text":"block_n_found_modules_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe number of found gene modules for each block. We identify a different number of gene modules for each block. Due to Daf limitations, we set the size  of the modules axis to the maximal number of gene modules in a block. The coefficients for the extra gene modules for each block are set to zero.\n\nThis vector is populated by compute_blocks_n_found_modules!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_n_used_modules_vector","page":"Contracts","title":"Metacells.Contracts.block_n_used_modules_vector","text":"block_n_used_modules_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe number of used gene modules for each block. We disqualify some of the found gene modules, if they contain a high fraction of lateral genes.\n\nThis vector is populated by compute_blocks_n_used_modules!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_modules_RMSE_vector","page":"Contracts","title":"Metacells.Contracts.block_modules_RMSE_vector","text":"block_modules_RMSE_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe root mean squared error of predicting the covered genes using the gene modules in the vicinity of the block. This considers all the metacells, so it is vulnerable to overfitting.\n\nThis vector is populated by compute_blocks_modules!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_modules_XRMSE_vector","page":"Contracts","title":"Metacells.Contracts.block_modules_XRMSE_vector","text":"block_modules_XRMSE_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe cross-validated root mean squared error of predicting the covered genes using the gene modules in the vicinity of the block. This is similar to the RMSE, but is computed using cross-validation (training the model on a subset of the local metacells, and evaluating it on the rest). This will be higher than the RMSE; the difference is an indicator of the overfitting of the linear model, which should be low relative to the total RMSE.\n\nThis vector is populated by compute_blocks_modules!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_modules_block_RMSE_vector","page":"Contracts","title":"Metacells.Contracts.block_modules_block_RMSE_vector","text":"block_modules_block_RMSE_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe root mean squared error of predicting the covered genes using the gene modules in the vicinity of the block, evaluated at the block metacells.\n\nThis vector is populated by compute_blocks_modules_block_RMSE!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_modules_neighborhood_RMSE_vector","page":"Contracts","title":"Metacells.Contracts.block_modules_neighborhood_RMSE_vector","text":"block_modules_neighborhood_RMSE_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nThe root mean squared error of predicting the covered genes using the gene modules in the vicinity of the block, evaluated at the neighborhood metacells.\n\nThis vector is populated by compute_blocks_modules_neighborhood_RMSE!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Type-Vectors","page":"Contracts","title":"Type Vectors","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.type_color_vector","page":"Contracts","title":"Metacells.Contracts.type_color_vector","text":"type_color_vector(expectation::ContractExpectation)::Pair{VectorKey, DataSpecification}\n\nA unique color for each type for graphs.\n\nThis vector is created in a supervised way based on biological considerations and conventions (e.g., red blood cells are often given some red color). It is also possible to use Chameleon to automatically assign colors to cell types based on gene expression levels.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Matrices","page":"Contracts","title":"Matrices","text":"","category":"section"},{"location":"contracts.html#Cell-Matrices","page":"Contracts","title":"Cell Matrices","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.cell_gene_UMIs_matrix","page":"Contracts","title":"Metacells.Contracts.cell_gene_UMIs_matrix","text":"cell_gene_UMIs_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe number of UMIs collected for each gene for each cell. This is the \"ground truth\" everything else is built on. The total number of UMIs is different (sometimes wildly) in each cell, based on the scRNA-seq technology and protocol.\n\nThis data is obtained from scRNA-seq experiments.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacell-Matrices","page":"Contracts","title":"Metacell Matrices","text":"","category":"section"},{"location":"contracts.html#Metacell-UMIs","page":"Contracts","title":"Metacell UMIs","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_UMIs_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_UMIs_matrix","text":"metacell_gene_UMIs_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe total number of UMIs used to estimate the fraction of each gene in each metacell. This can be used to estimate the robustness of the fraction.\n\nThis matrix is populated by compute_metacells_genes_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacell-Geomean-Fractions","page":"Contracts","title":"Metacell Geomean Fractions","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_geomean_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_geomean_fraction_matrix","text":"metacell_gene_geomean_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nAn estimated geomean fraction of the UMIs of each gene in each metacell. We use geomean in an attempt to combat the disproportionate effect of a few cells with very high gene expression (\"bursty\" genes), and then normalizes the fractions to sum to one. While effective, this has the unfortunate effect of inflating the value of weak genes.\n\nThis matrix is populated by compute_metacells_genes_geomean_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_log_geomean_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_log_geomean_fraction_matrix","text":"metacell_gene_log_geomean_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the estimated geomean fraction of the UMIs of each gene in each metacell. This adds some gene fraction regularization to deal with zero fractions. Using the log makes it easier to visualize, and the difference between log values (the \"fold factor\", log base 2 of the ratio between the expression levels) is a good measure of difference between gene expression levels.\n\nThis matrix is populated by compute_metacells_genes_log_geomean_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacell-Linear-Fractions","page":"Contracts","title":"Metacell Linear Fractions","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_linear_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_linear_fraction_matrix","text":"metacell_gene_linear_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nAn estimated linear fraction of the UMIs of each gene in each metacell, out of the total UMIs. This is the \"best\" estimate assuming multinomial sampling noise. However, this is sensitive to a few cells with very high expression levels (\"bursty\" genes), as these impact the denominator.\n\nThis matrix is populated by compute_metacells_genes_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_scaled_linear_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_scaled_linear_fraction_matrix","text":"metacell_gene_scaled_linear_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe estimated linear fraction of the UMIs of each gene in each metacell, out of the total UMIs, scaled by divergence.\n\nThis matrix is populated by compute_metacells_genes_scaled_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_log_linear_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_log_linear_fraction_matrix","text":"metacell_gene_log_linear_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the estimated linear fraction of the UMIs of each gene in each metacell, out of the total UMIs. This adds some gene fraction regularization to deal with zero fractions. Using the log makes it easier to visualize, and the difference between log values (the \"fold factor\", log base 2 of the ratio between the expression levels) is a good measure of difference between gene expression levels.\n\nThis matrix is populated by compute_metacells_genes_log_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_log_scaled_linear_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_log_scaled_linear_fraction_matrix","text":"metacell_gene_log_scaled_linear_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the scaled estimated linear fraction of the UMIs of each gene in each metacell. This adds some gene fraction regularization to deal with zero fractions.\n\nThis matrix is populated by compute_metacells_genes_log_scaled_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacell-Linear-Covered-Fractions","page":"Contracts","title":"Metacell Linear Covered Fractions","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_linear_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_linear_covered_fraction_matrix","text":"metacell_gene_linear_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nAn estimated linear fraction of the UMIs of each covered gene in each metacell, out of the total covered UMIs. By considering only the covered genes this avoid the impact of highly-expressed lateral genes (e.g., cell cycle).\n\nThis matrix is populated by compute_metacells_genes_linear_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_scaled_linear_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_scaled_linear_covered_fraction_matrix","text":"metacell_gene_scaled_linear_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe estimated linear fraction of the UMIs of each covered gene in each metacell, out of the total covered UMIs, scaled by divergence. By considering only the covered genes this avoid the impact of highly-expressed lateral genes (e.g., cell cycle).\n\nThis matrix is populated by compute_metacells_genes_scaled_linear_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_log_linear_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_log_linear_covered_fraction_matrix","text":"metacell_gene_log_linear_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the estimated linear fraction of the UMIs of each covered gene in each metacell, out of the total covered UMIs. By considering only the covered genes this avoid the impact of highly-expressed lateral genes (e.g., cell cycle).\n\nThis matrix is populated by compute_metacells_genes_log_linear_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_log_scaled_linear_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_log_scaled_linear_covered_fraction_matrix","text":"metacell_gene_log_scaled_linear_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the estimated linear fraction of the UMIs of each covered gene in each metacell, out of the total covered UMIs, scaled by divergence. By considering only the covered genes this avoid the impact of highly-expressed lateral genes (e.g., cell cycle).\n\nThis matrix is populated by compute_metacells_genes_log_scaled_linear_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacell-Virtual-Fractions","page":"Contracts","title":"Metacell Virtual Fractions","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_fraction_matrix","text":"metacell_gene_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nSome estimated fraction of the UMIs of each gene in each metacell. This is a \"virtual\" matrix, that is, generic code uses it and expects an adapter to map it to one of the concrete metacell_gene_*_fraction_matrix matrices.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_log_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_log_fraction_matrix","text":"metacell_gene_log_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of some estimated linear fraction of the UMIs of each gene in each metacell. This is a \"virtual\" matrix, that is, generic code uses it and expects an adapter to map it to one of the concrete metacell_gene_log_*_fraction_matrix matrices.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_covered_fraction_matrix","text":"metacell_gene_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nSome estimated fraction of the UMIs of each covered gene in each metacell. This is a \"virtual\" matrix, that is, generic code uses it and expects an adapter to map it to one of the concrete metacell_gene_*_covered_fraction_matrix matrices.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_log_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_log_covered_fraction_matrix","text":"metacell_gene_log_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of some estimated linear fraction of the UMIs of each covered gene in each metacell. This is a \"virtual\" matrix, that is, generic code uses it and expects an adapter to map it to one of the concrete metacell_gene_log_*_covered_fraction_matrix matrices.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacell-Distances","page":"Contracts","title":"Metacell Distances","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_metacell_max_skeleton_fold_distance","page":"Contracts","title":"Metacells.Contracts.metacell_metacell_max_skeleton_fold_distance","text":"metacell_metacell_max_skeleton_fold_distance(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe maximal fold factor between skeleton genes between the metacells. This is a symmetric distances matrix with zeros at the diagonal. The exact semantics depend on the estimated fractions used to compute the distances.\n\nThis matrix is populated by compute_blocks!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Gene-Modules-Analysis-2","page":"Contracts","title":"Gene Modules Analysis","text":"","category":"section"},{"location":"contracts.html#Gene-Modules-UMIs","page":"Contracts","title":"Gene Modules UMIs","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_module_total_UMIs_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_module_total_UMIs_matrix","text":"metacell_module_total_UMIs_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe total UMIs of the genes of each module in each metacell.\n\nThis matrix is populated by compute_metacells_modules_total_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_module_scaled_total_UMIs_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_module_scaled_total_UMIs_matrix","text":"metacell_module_scaled_total_UMIs_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe total UMIs of the genes of each module in each metacell, scaled by divergence.\n\nThis matrix is populated by compute_metacells_modules_scaled_total_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_module_covered_UMIs_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_module_covered_UMIs_matrix","text":"metacell_module_covered_UMIs_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe total UMIs of the covered genes of each module in each metacell.\n\nThis matrix is populated by compute_metacells_modules_covered_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_module_scaled_covered_UMIs_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_module_scaled_covered_UMIs_matrix","text":"metacell_module_scaled_covered_UMIs_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe total UMIs of the covered genes of each module in each metacell, scaled by divergence.\n\nThis matrix is populated by compute_metacells_modules_scaled_covered_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Gene-Modules-Linear-Fractions","page":"Contracts","title":"Gene Modules Linear Fractions","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_module_linear_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_module_linear_fraction_matrix","text":"metacell_module_linear_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe estimated linear fraction of the UMIs of the genes of each module in each metacell, out of the total UMIs.\n\nThis matrix is populated by compute_metacells_modules_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_module_scaled_linear_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_module_scaled_linear_fraction_matrix","text":"metacell_module_scaled_linear_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe estimated linear fraction of the UMIs of the genes of each module in each metacell, out of the total UMIs, scaled by divergence.\n\nThis matrix is populated by compute_metacells_modules_scaled_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_module_log_linear_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_module_log_linear_fraction_matrix","text":"metacell_module_log_linear_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the estimated linear fraction of the UMIs of the genes of each module in each metacell, out of the total UMIs. This adds some gene fraction regularization to deal with zero fractions.\n\nThis matrix is populated by compute_metacells_modules_log_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_module_log_scaled_linear_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_module_log_scaled_linear_fraction_matrix","text":"metacell_module_log_scaled_linear_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the estimated linear fraction of the UMIs of the genes of each module in each metacell, out of the total UMIs, scaled by divergence. This adds some gene fraction regularization to deal with zero fractions.\n\nThis matrix is populated by compute_metacells_modules_log_scaled_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Gene-Modules-Linear-Covered-Fractions","page":"Contracts","title":"Gene Modules Linear Covered Fractions","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_module_linear_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_module_linear_covered_fraction_matrix","text":"metacell_module_linear_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe estimated linear fraction of the UMIs of the covered genes of each module in each metacell, out of the total covered UMIs.\n\nThis matrix is populated by compute_metacells_modules_linear_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_module_scaled_linear_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_module_scaled_linear_covered_fraction_matrix","text":"metacell_module_scaled_linear_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe estimated linear fraction of the UMIs of the covered genes of each module in each metacell, out of the total covered UMIs, scaled by divergence.\n\nThis matrix is populated by compute_metacells_modules_scaled_linear_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_module_log_linear_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_module_log_linear_covered_fraction_matrix","text":"metacell_module_log_linear_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the estimated linear fraction of the UMIs of the covered genes of each module in each metacell, out of the total covered UMIs. This adds some gene fraction regularization to deal with zero fractions.\n\nThis matrix is populated by compute_metacells_modules_log_linear_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_module_log_scaled_linear_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_module_log_scaled_linear_covered_fraction_matrix","text":"metacell_module_log_scaled_linear_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the estimated linear fraction of the UMIs of the covered genes of each module in each metacell, out of the total covered UMIs, scaled by divergence. This adds some gene fraction regularization to deal with zero fractions.\n\nThis matrix is populated by compute_metacells_modules_log_scaled_linear_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Gene-Modules-Approximated-Covered-Fractions","page":"Contracts","title":"Gene Modules Approximated Covered Fractions","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_approximated_linear_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_approximated_linear_covered_fraction_matrix","text":"metacell_gene_approximated_linear_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe linear fraction of each covered gene UMIs out of the total covered UMIs as approximated by the linear model.\n\nThis matrix is populated by compute_metacells_genes_approximated_linear_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_approximated_scaled_linear_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_approximated_scaled_linear_covered_fraction_matrix","text":"metacell_gene_approximated_scaled_linear_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe linear fraction of each covered gene UMIs out of the total covered UMIs, scaled by divergence, as approximated by the linear model.\n\nThis matrix is populated by compute_metacells_genes_approximated_scaled_linear_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_approximated_log_linear_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_approximated_log_linear_covered_fraction_matrix","text":"metacell_gene_approximated_log_linear_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the linear fraction of each covered gene UMIs out of the total covered UMIs as approximated by the linear model. This adds some gene fraction regularization to deal with zero fractions.\n\nThis matrix is populated by compute_metacells_genes_approximated_log_linear_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_approximated_log_scaled_linear_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_approximated_log_scaled_linear_covered_fraction_matrix","text":"metacell_gene_approximated_log_scaled_linear_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the linear fraction of each covered gene UMIs out of the total covered UMIs, scaled by divergence, as approximated by the linear model. This adds some gene fraction regularization to deal with zero fractions.\n\nThis matrix is populated by compute_metacells_genes_approximated_log_scaled_linear_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Gene-Modules-Virtual-Fractions","page":"Contracts","title":"Gene Modules Virtual Fractions","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.metacell_module_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_module_fraction_matrix","text":"metacell_module_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nSome estimated fraction of the UMIs of each gene in each module. This is a \"virtual\" matrix, that is, generic code uses it and expects an adapter to map it to one of the concrete metacell_module_*_fraction_matrix matrices.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_module_log_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_module_log_fraction_matrix","text":"metacell_module_log_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of some estimated linear fraction of the UMIs of each module in each metacell. This is a \"virtual\" matrix, that is, generic code uses it and expects an adapter to map it to one of the concrete metacell_module_log_*_fraction_matrix matrices.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_module_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_module_covered_fraction_matrix","text":"metacell_module_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nSome estimated fraction of the UMIs of each covered gene in each module. This is a \"virtual\" matrix, that is, generic code uses it and expects an adapter to map it to one of the concrete metacell_module_*_covered_fraction_matrix matrices.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_module_log_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_module_log_covered_fraction_matrix","text":"metacell_module_log_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of some estimated linear fraction of the covered UMIs of each module in each metacell. This is a \"virtual\" matrix, that is, generic code uses it and expects an adapter to map it to one of the concrete metacell_module_log_*_covered_fraction_matrix matrices.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_approximated_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_approximated_covered_fraction_matrix","text":"metacell_gene_approximated_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe fraction of each covered gene UMIs out of the total covered UMIs as approximated by the linear model. This is a \"virtual\" matrix, that is, generic code uses it and expects an adapter to map it to one of the concrete metacell_gene_approximated_*_fraction_matrix matrices.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.metacell_gene_approximated_log_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.metacell_gene_approximated_log_covered_fraction_matrix","text":"metacell_gene_approximated_log_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the fraction of each covered gene UMIs out of the total covered UMIs as approximated by the linear model. This is a \"virtual\" matrix, that is, generic code uses it and expects an adapter to map it to one of the concrete metacell_gene_approximated_log_*_fraction_matrix matrices.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Block-Matrices","page":"Contracts","title":"Block Matrices","text":"","category":"section"},{"location":"contracts.html#Block-Distances","page":"Contracts","title":"Block Distances","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_block_max_skeleton_fold_distance","page":"Contracts","title":"Metacells.Contracts.block_block_max_skeleton_fold_distance","text":"block_block_max_skeleton_fold_distance(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe maximal fold factor between skeleton genes between the metacells of the blocks. This is a symmetric distances matrix. The diagonal contains the maximal fold factor between skeleton genes between metacells in a single block, which is only zero for single-metacell blocks.\n\nThis matrix is populated by compute_blocks!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Block-Vicinities","page":"Contracts","title":"Block Vicinities","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_block_is_in_neighborhood_matrix","page":"Contracts","title":"Metacells.Contracts.block_block_is_in_neighborhood_matrix","text":"block_block_is_in_neighborhood_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nFor each block, the (column) mask of nearby blocks in its immediate neighborhood. The neighborhood consists of a small number of very close blocks, which we use as the basis for evaluating local approximations of the manifold.\n\nThis matrix is populated by compute_blocks_is_in_neighborhood!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_block_is_in_environment_matrix","page":"Contracts","title":"Metacells.Contracts.block_block_is_in_environment_matrix","text":"block_block_is_in_environment_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nFor each block, the (column) mask of nearby blocks in its linear environment. The environment consists of a larger region than the neighborhood, which we use as the basis for computing local approximations of the manifold.\n\nThis matrix is populated by compute_blocks_is_in_environment!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Block-UMIs","page":"Contracts","title":"Block UMIs","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_gene_UMIs_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_UMIs_matrix","text":"block_gene_UMIs_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe total number of UMIs used to estimate the fraction of each gene in each block. This can used to estimate the robustness of the fraction.\n\nThis matrix is populated by compute_blocks_genes_UMIs!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Block-Linear-Fractions","page":"Contracts","title":"Block Linear Fractions","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_gene_linear_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_linear_fraction_matrix","text":"block_gene_linear_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nAn estimated linear fraction of the UMIs of each gene out of the total UMIs in each block.\n\nThis matrix is populated by compute_blocks_genes_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_scaled_linear_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_scaled_linear_fraction_matrix","text":"block_gene_scaled_linear_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe estimated linear fraction of the UMIs of each gene out of the total UMIs in each block, scaled by divergence.\n\nThis matrix is populated by compute_blocks_genes_scaled_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_log_linear_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_log_linear_fraction_matrix","text":"block_gene_log_linear_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the estimated linear fraction of the UMIs of each gene out of the total UMIs in each block.\n\nThis matrix is populated by compute_blocks_genes_log_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_log_scaled_linear_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_log_scaled_linear_fraction_matrix","text":"block_gene_log_scaled_linear_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the scaled estimated linear fraction of the UMIs of each gene out of the total UMIs in each block, scaled by divergence.\n\nThis matrix is populated by compute_blocks_genes_log_scaled_linear_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Block-Linear-Covered-Fractions","page":"Contracts","title":"Block Linear Covered Fractions","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_gene_linear_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_linear_covered_fraction_matrix","text":"block_gene_linear_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nAn estimated linear fraction of the UMIs of each covered gene out of the total covered UMIs in each block.\n\nThis matrix is populated by compute_blocks_genes_linear_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_scaled_linear_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_scaled_linear_covered_fraction_matrix","text":"block_gene_scaled_linear_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe estimated linear fraction of the UMIs of each covered gene out of the total covered UMIs in each block, scaled by divergence.\n\nThis matrix is populated by compute_blocks_genes_log_linear_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_log_linear_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_log_linear_covered_fraction_matrix","text":"block_gene_log_linear_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the estimated linear fraction of the UMIs of each covered gene out of the total covered UMIs in each block.\n\nThis matrix is populated by compute_blocks_genes_log_linear_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_log_scaled_linear_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_log_scaled_linear_covered_fraction_matrix","text":"block_gene_log_scaled_linear_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of the scaled estimated linear fraction of the UMIs of each covered gene out of the total covered UMIs in each block.\n\nThis matrix is populated by compute_blocks_genes_log_scaled_linear_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Block-Virtual-Fractions","page":"Contracts","title":"Block Virtual Fractions","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_gene_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_fraction_matrix","text":"block_gene_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nSome estimated fraction of the UMIs of each gene in each block. This is a \"virtual\" matrix, that is, generic code uses it and expects an adapter to map it to one of the concrete block_gene_*_fraction_matrix matrices.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_log_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_log_fraction_matrix","text":"block_gene_log_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of some estimated linear fraction of the UMIs of each gene in each block. This is a \"virtual\" matrix, that is, generic code uses it and expects an adapter to map it to one of the concrete block_gene_log_*_fraction_matrix matrices.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_covered_fraction_matrix","text":"block_gene_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nSome estimated fraction of the UMIs of each covered gene in each block. This is a \"virtual\" matrix, that is, generic code uses it and expects an adapter to map it to one of the concrete block_gene_*_covered_fraction_matrix matrices.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_log_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_log_covered_fraction_matrix","text":"block_gene_log_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe log base 2 of some estimated linear fraction of the UMIs of each covered gene in each block. This is a \"virtual\" matrix, that is, generic code uses it and expects an adapter to map it to one of the concrete block_gene_log_*_covered_fraction_matrix matrices.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Block-Gene-Masks","page":"Contracts","title":"Block Gene Masks","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_gene_is_neighborhood_marker","page":"Contracts","title":"Metacells.Contracts.block_gene_is_neighborhood_marker","text":"block_gene_is_neighborhood_marker(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nA mask of genes that distinguish between cell states in each neighborhood.\n\nThis matrix is populated by compute_blocks_genes_is_neighborhood_markers!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_is_environment_marker","page":"Contracts","title":"Metacells.Contracts.block_gene_is_environment_marker","text":"block_gene_is_environment_marker(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nA mask of genes that distinguish between cell states in each environment.\n\nThis matrix is populated by compute_blocks_genes_is_environment_markers!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Principal-Components-Analysis-2","page":"Contracts","title":"Principal Components Analysis","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_principal_component_is_used_matrix","page":"Contracts","title":"Metacells.Contracts.block_principal_component_is_used_matrix","text":"block_principal_component_is_used_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nWhether each principal component is used by each block. This mask is true for the first n_used_principal_components of each block and false for the rest. It is useful for constructing Daf queries that only return coefficients for the used principal components for a specific block (e.g., gene & is_skeleton / principal_component & is_used ; block = $(block_name) : $(block_name)_skeleton_coefficient).\n\nThis matrix is populated by compute_blocks_is_in_environment!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_gene_base_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_base_covered_fraction_matrix","text":"block_gene_base_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe covered base fractions used by the principal component analysis. The model computes the principal components by the difference of the skeleton genes from these levels, and then uses them to predict the difference from these levels of all the covered genes (including the skeleton genes).\n\nThis matrix is populated by compute_blocks_is_in_environment!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_principal_component_gene_skeleton_coefficient_tensor","page":"Contracts","title":"Metacells.Contracts.block_principal_component_gene_skeleton_coefficient_tensor","text":"block_principal_component_gene_skeleton_coefficient_tensor(\n    expectation::ContractExpectation\n)::Pair{TensorKey, DataSpecification}\n\nThe coefficient of each skeleton gene for computing a principle component. This is zero for non-skeleton genes. The coefficients can be either positive or negative. Combined with the base_covered_fraction and the covered_coefficient matrices, this gives a local linear model for estimating all the covered genes (including the skeleton genes).\n\nThis matrix is populated by compute_blocks_is_in_environment!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_principal_component_gene_covered_coefficient_tensor","page":"Contracts","title":"Metacells.Contracts.block_principal_component_gene_covered_coefficient_tensor","text":"block_principal_component_gene_covered_coefficient_tensor(\n    expectation::ContractExpectation\n)::Pair{TensorKey, DataSpecification}\n\nThe coefficient of each principal component for computing each covered gene. This is zero for uncovered genes. Combined with the base_covered_fraction and the skeleton_coefficient matrices, this gives a local linear model for estimating all the covered genes (including the skeleton genes).\n\nThis matrix is populated by compute_blocks_is_in_environment!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Gene-Modules-Analysis-3","page":"Contracts","title":"Gene Modules Analysis","text":"","category":"section"},{"location":"contracts.html#Gene-Modules-Counts","page":"Contracts","title":"Gene Modules Counts","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_module_n_genes_matrix","page":"Contracts","title":"Metacells.Contracts.block_module_n_genes_matrix","text":"block_module_n_genes_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe number of genes in each gene module in each block. This is zero for the extra (not-found) gene modules.\n\nThis matrix is populated by compute_blocks_modules_n_genes!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_module_n_covered_matrix","page":"Contracts","title":"Metacells.Contracts.block_module_n_covered_matrix","text":"block_module_n_covered_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe number of covered genes in each gene module in each block. This is zero for the extra (not-found) gene modules.\n\nThis matrix is populated by compute_blocks_modules_n_covered!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Gene-Modules-UMIs-2","page":"Contracts","title":"Gene Modules UMIs","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_module_total_UMIs_matrix","page":"Contracts","title":"Metacells.Contracts.block_module_total_UMIs_matrix","text":"block_module_total_UMIs_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe total UMIs of the genes in each gene module in each block.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_module_scaled_total_UMIs_matrix","page":"Contracts","title":"Metacells.Contracts.block_module_scaled_total_UMIs_matrix","text":"block_module_scaled_total_UMIs_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe total UMIs of the genes in each gene module in each block, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_module_covered_UMIs_matrix","page":"Contracts","title":"Metacells.Contracts.block_module_covered_UMIs_matrix","text":"block_module_covered_UMIs_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe total UMIs of the covered genes in each gene module in each block.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_module_scaled_covered_UMIs_matrix","page":"Contracts","title":"Metacells.Contracts.block_module_scaled_covered_UMIs_matrix","text":"block_module_scaled_covered_UMIs_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe total UMIs of the covered genes in each gene module in each block, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Gene-Modules-Masks","page":"Contracts","title":"Gene Modules Masks","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_gene_module_index_matrix","page":"Contracts","title":"Metacells.Contracts.block_gene_module_index_matrix","text":"block_gene_module_index_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe index of the gene module each gene belongs to in the environment of each block. This is an index and not a module name because of Daf limitations (no matrices of strings). The index is zero for genes that do not belong to any module.\n\nThis matrix is populated by compute_blocks_modules!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_module_is_found_matrix","page":"Contracts","title":"Metacells.Contracts.block_module_is_found_matrix","text":"block_module_is_found_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nWhether each gene module is found in each block. This mask is true for the first n_found_modules of each block and false for the rest. Due to Daf limitations, we create a module axis with the maximal number of gene modules in each block, so only the first n_found_modules of these actually contain genes.\n\nThis matrix is populated by compute_blocks_modules!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_module_is_used_matrix","page":"Contracts","title":"Metacells.Contracts.block_module_is_used_matrix","text":"block_module_is_used_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nWhether each gene module is used in the linear model of each block. Only some of the found models are actually used in the local linear model.\n\nThis matrix is populated by compute_blocks_modules_is_used!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Gene-Modules-Metadata","page":"Contracts","title":"Gene Modules Metadata","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_module_min_gene_correlation_matrix","page":"Contracts","title":"Metacells.Contracts.block_module_min_gene_correlation_matrix","text":"block_gene_module_min_gene_correlation_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe minimal correlation between the genes of each gene module of each block.\n\nThis matrix is populated by compute_blocks_modules!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Gene-Modules-Model","page":"Contracts","title":"Gene Modules Model","text":"","category":"section"},{"location":"contracts.html#Metacells.Contracts.block_module_base_covered_fraction_matrix","page":"Contracts","title":"Metacells.Contracts.block_module_base_covered_fraction_matrix","text":"block_module_base_covered_fraction_matrix(expectation::ContractExpectation)::Pair{MatrixKey, DataSpecification}\n\nThe base covered fractions used by the gene modules analysis. The model computes the difference of each gene module fraction in each metacell (or cell) from these levels, then uses them to predict the difference from the base_covered_fraction of each covered gene (including the modules genes) using the covered_coefficient matrix.\n\nThis matrix is populated by compute_blocks_modules_base_covered_fractions!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Metacells.Contracts.block_module_gene_covered_coefficient_tensor","page":"Contracts","title":"Metacells.Contracts.block_module_gene_covered_coefficient_tensor","text":"block_module_gene_covered_coefficient_tensor(\n    expectation::ContractExpectation\n)::Pair{TensorKey, DataSpecification}\n\nThe coefficient of each gene module for computing each covered gene. This is zero for unused modules and uncovered genes. Combined with the module_fraction and the covered_coefficient matrices, this gives a local linear model for estimating all the covered genes (including the modules genes).\n\nThis matrix is populated by compute_approximation!.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Index","page":"Contracts","title":"Index","text":"","category":"section"},{"location":"contracts.html","page":"Contracts","title":"Contracts","text":"Pages = [\"contracts.md\"]","category":"page"},{"location":"analyze_genes.html#Analyze-Genes","page":"Analyze Genes","title":"Analyze Genes","text":"","category":"section"},{"location":"analyze_genes.html#Metacells.AnalyzeGenes","page":"Analyze Genes","title":"Metacells.AnalyzeGenes","text":"Do simple per-gene analysis.\n\n\n\n\n\n","category":"module"},{"location":"analyze_genes.html#Metacells.AnalyzeGenes.compute_genes_divergence!","page":"Analyze Genes","title":"Metacells.AnalyzeGenes.compute_genes_divergence!","text":"function compute_genes_divergence!(\n    daf::DafWriter;\n    min_divergent_gene_range_fold::Real = ```7```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nCompute a divergence factor for all genes. We need this because when computing any form of squared error, \"bursty\" genes with a very wide range of expression level tend to over-influence the results. We therefore compute a scaled expression level by multiplying the raw expression level by 1.0 - divergence. For most (\"well behaved\") genes, the divergence will be 0. For genes whose fold factor between the highest and lowest (log base 2) expression level is above min_divergent_gene_range_fold, we compute a divergence factor such that the above scaling will reduce this fold factor to the min_divergent_gene_range_fold threshold.\n\nnote: Note\nThe computation depends on the gene_fraction_regularization, so it is important to give it the same value as the one given to compute_metacells_log_*_fractions!.\n\nThis is admittedly a blunt instrument, but it is the least-bad option we have for now. It beats the old method of manually constructing an is_noisy genes mask.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nMatrices\n\ngene, metacell @ linear_fraction::Union{Float32, Float64} (required): The estimated linear fraction of the UMIs of each gene in each metacell, out of the total UMIs.\n\nOutputs\n\nVectors\n\ngene @ divergence::Union{Float32, Float64} (guaranteed): Scale fold factors of each gene by multiplying with (1 - divergence) of the gene.\n\n\n\n\n\n","category":"function"},{"location":"analyze_genes.html#Metacells.AnalyzeGenes.identify_marker_genes!","page":"Analyze Genes","title":"Metacells.AnalyzeGenes.identify_marker_genes!","text":"function identify_marker_genes!(\n    daf::DafWriter;\n    min_marker_gene_max_fraction::AbstractFloat = ```0.0001```,\n    min_marker_gene_range_fold::Real = ```2```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nIdentify the genes that distinguish at least one metacell from the rest. Such genes are called \"marker\" genes as they (potentially) mark specific cell states. If overwrite, will overwrite an existing is_marker mask.\n\nMarker genes are genes which:\n\nHave a maximal gene expression level of at least min_marker_gene_max_fraction, and\nHave a range of expression of at least min_marker_gene_range_fold between the maximal and minimal (log base 2) of the expression level.\n\nnote: Note\nThis uses the virtual metacell_gene_fraction_matrix and metacell_gene_log_fraction_matrix. You will need an adapter to map these to concrete fractions (geomean, linear, scaled, ...). Make sure you are consistent when mapping the fractions and log-fraction matrices.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nMatrices\n\ngene, metacell @ fraction::Union{Float32, Float64} (required): Some estimated fraction of the UMIs of each gene in each metacell.\n\ngene, metacell @ log_fraction::Union{Float32, Float64} (required): The log base 2 of some estimated fraction of the UMIs of each gene in each metacell.\n\nOutputs\n\nVectors\n\ngene @ is_marker::Bool (guaranteed): A mask of genes that distinguish between cell states.\n\n\n\n\n\n","category":"function"},{"location":"analyze_genes.html#Metacells.AnalyzeGenes.rank_marker_genes!","page":"Analyze Genes","title":"Metacells.AnalyzeGenes.rank_marker_genes!","text":"function rank_marker_genes!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nCompute the relative ranks of marker genes.\n\nCompute the median of the (log base 2) of the gene expression level for each marker gene across all the metacells.\nCompute the per-marker-per-metacell fold factor (absolute difference of the log expression from the median).\nRank the markers for each metacell (1 having the largest fold factor relative to the median).\nFor each marker, give it a priority which is a tuple of (1) the minimal rank it has in all metacells (2) the maximal fold it has in metacells where it has that rank (negated).\nSort the markers according to this priority.\n\nNon-marker genes are given a rank of typemax(UInt32) regardless of their expression level in the metacells.\n\nnote: Note\nThis uses the virtual metacell_gene_log_fraction_matrix. You will need an adapter to map these to concrete fractions (geomean, linear, scaled, ...).\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ is_marker::Bool (required): A mask of genes that distinguish between cell states.\n\nMatrices\n\ngene, metacell @ log_fraction::Union{Float32, Float64} (required): The log base 2 of some estimated fraction of the UMIs of each gene in each metacell.\n\nOutputs\n\nVectors\n\ngene @ marker_rank::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The ralative ranks of the marker genes.\n\n\n\n\n\n","category":"function"},{"location":"analyze_genes.html#Metacells.AnalyzeGenes.identify_uncorrelated_genes!","page":"Analyze Genes","title":"Metacells.AnalyzeGenes.identify_uncorrelated_genes!","text":"function identify_uncorrelated_genes!(\n    daf::DafWriter;\n    correlation_confidence::AbstractFloat = ```0.99```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nIdentify marker genes that are correlated with other gene(s). Such genes are good candidates for looking for groups of genes that act together. If overwrite, will overwrite an existing is_correlated mask.\n\nCorrelate the (log base 2 of the) expression level between all the pairs of genes.\nFor each gene, shuffle its values along all metacells, and again correlate this between all the pairs of genes.\nFind the maximal absolute correlation for each gene in both cases (that is, strong anti-correlation also counts).\nFind the correlation_confidence quantile correlation of the shuffled data.\nIdentify the genes that have at least that level of correlations in the unshuffled data.\n\nnote: Note\nThis uses the virtual metacell_gene_log_fraction_matrix. You will need an adapter to map these to concrete fractions (geomean, linear, scaled, ...). While at it, you should probably also restrict the set of genes to the marker genes.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nMatrices\n\ngene, metacell @ log_fraction::Union{Float32, Float64} (required): The log base 2 of some estimated fraction of the UMIs of each gene in each metacell.\n\nOutputs\n\nVectors\n\ngene @ is_uncorrelated::Bool (guaranteed): A mask of genes that are not correlated with other gene(s).\n\n\n\n\n\n","category":"function"},{"location":"analyze_genes.html#Metacells.AnalyzeGenes.identify_covered_genes!","page":"Analyze Genes","title":"Metacells.AnalyzeGenes.identify_covered_genes!","text":"function identify_covered_genes!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nIdentify the genes that will be approximated by the local linear programs. Picking them is simple: we cover all marker genes, that are not lateral, and not uncorrelated.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ is_marker::Bool (required): A mask of genes that distinguish between cell states.\n\ngene @ is_lateral::Bool (required): A mask of genes that are lateral to the biological behaviors of interest.\n\ngene @ is_uncorrelated::Bool (required): A mask of genes that are not correlated with other gene(s).\n\nOutputs\n\nVectors\n\ngene @ is_covered::Bool (guaranteed): A mask of genes that are covered by the local linear program.\n\n\n\n\n\n","category":"function"},{"location":"analyze_genes.html#Metacells.AnalyzeGenes.identify_skeleton_genes!","page":"Analyze Genes","title":"Metacells.AnalyzeGenes.identify_skeleton_genes!","text":"function identify_skeleton_genes!(\n    daf::DafWriter;\n    max_skeleton_genes::Integer = ```200```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nIdentify the skeleton genes that will be used to predict the rest of the (covered) genes. We just pick the max_skeleton_genes that have the lowest marker_rank out of the covered genes.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\ngene @ marker_rank::Union{UInt16, UInt32, UInt64, UInt8} (required): The ralative ranks of the marker genes.\n\nOutputs\n\nVectors\n\ngene @ is_skeleton::Bool (guaranteed): A mask of genes that are used to predict the values of the rest of the (covered) genes.\n\n\n\n\n\n","category":"function"},{"location":"analyze_genes.html#Index","page":"Analyze Genes","title":"Index","text":"","category":"section"},{"location":"analyze_genes.html","page":"Analyze Genes","title":"Analyze Genes","text":"Pages = [\"analyze_genes.md\"]","category":"page"},{"location":"analyze_cells.html#Analyze-Cells","page":"Analyze Cells","title":"Analyze Cells","text":"","category":"section"},{"location":"analyze_cells.html#Metacells.AnalyzeCells","page":"Analyze Cells","title":"Metacells.AnalyzeCells","text":"Do simple per-cell analysis.\n\n\n\n\n\n","category":"module"},{"location":"analyze_cells.html#Metacells.AnalyzeCells.compute_cells_total_UMIs!","page":"Analyze Cells","title":"Metacells.AnalyzeCells.compute_cells_total_UMIs!","text":"function compute_cells_total_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nCompute the total UMIs of the genes in each cell.\n\nInputs\n\nAxes\n\ncell (optional): Sequenced single cells.\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ is_excluded::Bool (required): A mask of genes that are totally excluded from the analysis.\n\nMatrices\n\ngene, cell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of UMIs collected for each gene for each cell.\n\nOutputs\n\nVectors\n\ncell @ total_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of UMIs of all the genes in each cell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_cells.html#Metacells.AnalyzeCells.compute_cells_covered_UMIs!","page":"Analyze Cells","title":"Metacells.AnalyzeCells.compute_cells_covered_UMIs!","text":"function compute_cells_covered_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nCompute the total UMIs of the covered genes in each cell.\n\nInputs\n\nAxes\n\ncell (optional): Sequenced single cells.\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\nMatrices\n\ngene, cell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of UMIs collected for each gene for each cell.\n\nOutputs\n\nVectors\n\ncell @ covered_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of UMIs of all the covered genes in each cell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_cells.html#Index","page":"Analyze Cells","title":"Index","text":"","category":"section"},{"location":"analyze_cells.html","page":"Analyze Cells","title":"Analyze Cells","text":"Pages = [\"analyze_cells.md\"]","category":"page"},{"location":"analyze_approximation.html#Analyze-Approximation","page":"Analyze Approximation","title":"Analyze Approximation","text":"","category":"section"},{"location":"analyze_approximation.html#Metacells.AnalyzeApproximation","page":"Analyze Approximation","title":"Metacells.AnalyzeApproximation","text":"Do simple blocks analysis.\n\n\n\n\n\n","category":"module"},{"location":"analyze_approximation.html#Metacells.AnalyzeApproximation.compute_metacells_genes_approximated_linear_covered_fractions!","page":"Analyze Approximation","title":"Metacells.AnalyzeApproximation.compute_metacells_genes_approximated_linear_covered_fractions!","text":"function compute_metacells_genes_approximated_linear_covered_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe linear fraction of each covered gene UMIs out of the total covered UMIs as approximated by the linear model. This adds the gene_fraction_regularization to deal with zero fractions.\n\n\n\n\n\n","category":"function"},{"location":"analyze_approximation.html#Metacells.AnalyzeApproximation.compute_metacells_genes_approximated_scaled_linear_covered_fractions!","page":"Analyze Approximation","title":"Metacells.AnalyzeApproximation.compute_metacells_genes_approximated_scaled_linear_covered_fractions!","text":"function compute_metacells_genes_approximated_scaled_linear_covered_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe linear fraction of each covered gene UMIs out of the total covered UMIs, scaled by divergence, as approximated by the linear model. This adds the gene_fraction_regularization to deal with zero fractions.\n\n\n\n\n\n","category":"function"},{"location":"analyze_approximation.html#Metacells.AnalyzeApproximation.compute_metacells_genes_approximated_log_linear_covered_fractions!","page":"Analyze Approximation","title":"Metacells.AnalyzeApproximation.compute_metacells_genes_approximated_log_linear_covered_fractions!","text":"function compute_metacells_genes_approximated_log_linear_covered_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe log base 2 of the linear fraction of each covered gene UMIs out of the total covered UMIs as approximated by the linear model. This adds the gene_fraction_regularization to deal with zero fractions.\n\n\n\n\n\n","category":"function"},{"location":"analyze_approximation.html#Metacells.AnalyzeApproximation.compute_metacells_genes_approximated_log_scaled_linear_covered_fractions!","page":"Analyze Approximation","title":"Metacells.AnalyzeApproximation.compute_metacells_genes_approximated_log_scaled_linear_covered_fractions!","text":"function compute_metacells_genes_approximated_log_scaled_linear_covered_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe log base 2 of the linear fraction of each covered gene UMIs out of the total covered UMIs as approximated by the linear model, scaled by divergence. This adds the gene_fraction_regularization to deal with zero fractions.\n\n\n\n\n\n","category":"function"},{"location":"analyze_approximation.html#Metacells.AnalyzeApproximation.compute_blocks_modules_block_RMSE!","page":"Analyze Approximation","title":"Metacells.AnalyzeApproximation.compute_blocks_modules_block_RMSE!","text":"function compute_blocks_modules_block_RMSE!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe root mean squared error of predicting the covered genes using the gene modules in the vicinity of the block, evaluated at the block metacells.\n\nnote: Note\nThis compares the virtual metacell_gene_approximated_covered_fraction_matrix and metacell_gene_covered_fraction_matrix. You will need an adapter to map these to concrete fractions (geomean, linear, scaled, ...).\n\n\n\n\n\n","category":"function"},{"location":"analyze_approximation.html#Metacells.AnalyzeApproximation.compute_blocks_modules_neighborhood_RMSE!","page":"Analyze Approximation","title":"Metacells.AnalyzeApproximation.compute_blocks_modules_neighborhood_RMSE!","text":"function compute_blocks_modules_neighborhood_RMSE!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe root mean squared error of predicting the covered genes using the gene modules in the vicinity of the block, evaluated at the neighborhood metacells. This internally computes the approximation of the neighborhood metacells based on the block's model.\n\nnote: Note\nThis uses the metacell_gene_covered_fraction_matrix. You will need an adapter to map it to a concrete fraction (geomean, linear, scaled, ...).\n\n\n\n\n\n","category":"function"},{"location":"analyze_approximation.html#Index","page":"Analyze Approximation","title":"Index","text":"","category":"section"},{"location":"analyze_approximation.html","page":"Analyze Approximation","title":"Analyze Approximation","text":"Pages = [\"analyze_approximation.md\"]","category":"page"},{"location":"anndata_format.html#AnnData-Format","page":"AnnData Format","title":"AnnData Format","text":"","category":"section"},{"location":"anndata_format.html#Metacells.AnnDataFormat","page":"AnnData Format","title":"Metacells.AnnDataFormat","text":"Import and export cells and metacells data from/to h5ad files. This allows moving data between the old Python/C++ based AnnData world and the brave new Julia based Daf world.\n\nThe expected flow is as follows:\n\nCreate a Daf repository for the raw input cells and import the raw cells h5ad into it using import_cells_h5ad!.\nAlternatively, import just the clean cells h5ad into it, but that would be leaving out some of the data so is not recommended.\nCreate another Daf repository for the metacells, chain it to the cells repository, and import the metacells into it using import_metacells_h5ad!. Give this the cells-with-metacells data h5ad - only the assignment of cells to metacells will be imported from it.\nIf you have any per-cell or per-gene computed data in the cells-with-metacells data h5ad (unlikely, as computed data typically goes into the metacells h5ad), import it into the chained (metacells) repository using import_cells_h5ad!.\nCreate a type axis in the chained metacells Daf repository using reconstruct_type_axis!.\n\n\n\n\n\n","category":"module"},{"location":"anndata_format.html#Metacells.AnnDataFormat.import_cells_h5ad!","page":"AnnData Format","title":"Metacells.AnnDataFormat.import_cells_h5ad!","text":"function import_cells_h5ad!(\n    daf::DafWriter;\n    cells_h5ad::AbstractString,\n    copy_data::Maybe{CopyAnnData} = ```nothing```,\n    bestify::Bool = ```true```,\n    min_sparse_saving_fraction::AbstractFloat = ```0.25```,\n    overwrite::Bool = ```false```,\n    insist::Bool = ```false```,\n)::Nothing\n\nImport an AnnData based cells dataset into a destination daf data set. Ideally you'd copy the full (raw) cells into an empty Daf repository. Then, you'd treat this repository as read-only, and copy the metacells data using import_metacells_h5ad! into a separate Daf repository chained with the read-only cells repository. This allows separate alternative metacells computations to share the read-only cells data.\n\nYou can copy an h5ad file containing just the clean cells on top of the raw cells data, to capture any data computed during or after computing the metacells. You may need to specify the copy_data to specify defaults for values of properties that exist only for clean cells and/or genes. Or, you can skip copying the raw data altogether, copying just the clean data into the base cells repository, though this is less recommended as you are needlessly discarding data that may prove to be useful later.\n\nThe bestify, min_sparse_saving_fraction, overwrite, and insist have their usual meaning from Daf's copying functions.\n\nWhen copying, we apply the following general rules:\n\nA something_gene per-gene property and/or something_cell per-cell property are renamed to is_something, (and given a default of false), because Daf (unlike AnnData) has no problem with properties with the same name for different axes.\nSimilarly {gene,cell}[s]_something_module and something_{gene,cell}[s]_module properties are renamed to something_module. We add 1 to the value and store the results in a UInt32; that is, in Daf, module indices are 1-based, and 0 is \"no module\".\nAny something_umis is renamed to something_UMIs, given a default of 0, and stored as a UInt32.\n\nAnd we make the following special exceptions:\n\nScalars:\n\nWe do not copy the __name__ scalar.\nAll other scalars are copied as-is.\n\nPer-cell-per-gene:\n\nThe X matrix is renamed to UMIs, and stored as a UInt32.\nNo other per-cell-per-gene matrix is copied by default.\n\nPer-gene:\n\nThe per-gene correction_factor is given the default value 0.\nThe fitted per-gene vector is renamed to is_fitted and given the default false.\nThe significant_inner_folds_count per-gene property is stored as a UInt32 and given the default 0.\nThe full_gene_index property is not copied. Either you import the full (raw) data or you don't.\nAll other vectors are copied as-is.\n\nPer-cell:\n\nThe full_cell_index property is not copied. Either you import the full (raw) data or you don't.\nThe metacell, metacell_name, metacell_level, most_similar and most_similar_name per-cell properties are not copied. To import these, use import_metacells_h5ad!.\nAll other vectors are copied as-is.\n\nnote: Note\nIt is common to manually call reconstruct_axis! on the result to create additional axes (e.g., if the cells were collected from a set of batches and some properties are actually per-batch).\n\n\n\n\n\n","category":"function"},{"location":"anndata_format.html#Metacells.AnnDataFormat.import_metacells_h5ad!","page":"AnnData Format","title":"Metacells.AnnDataFormat.import_metacells_h5ad!","text":"function import_metacells_h5ad!(\n    daf::DafWriter;\n    cells_h5ad::AbstractString,\n    metacells_h5ad::AbstractString,\n    copy_data::Maybe{CopyAnnData} = ```nothing```,\n    bestify::Bool = ```true```,\n    min_sparse_saving_fraction::AbstractFloat = ```0.25```,\n    overwrite::Bool = ```false```,\n    insist::Bool = ```false```,\n)::Nothing\n\nImport an AnnData based metacells dataset into a destination daf data set. It is expected that you have first imported the per-cell data. Ideally you'd create a new empty repository for the metacells data and chained it on top of the per-cell repository, which you'd keep read-only to allow sharing it when you (inevitably) compute different metacells for it.\n\nThis behaves similarly to import_cells_h5ad!, specifically the generic rules (except that we copy per-metacell properties and not per-cell properties so the rules are adjusted accordingly), and we make the following special exceptions:\n\nPer-metacell-per-gene:\n\nThe X matrix is renamed to fraction and always stored as Float32.\nThe corrected_fraction matrix is always stored as Float32.\nThe essential matrix is renamed to is_essential.\nThe essential, fitted, and misfit matrices are renamed to is_essential, is_fitted and is_misfit, respectively.\nThe inner_fold, inner_stdev_log, projected_fold, projected_fraction matrices are always stored as Float32.\nThe total_umis matrix is renamed to UMIs and always stored as UInt32.\nThe zeros matrix is always stored as UInt32.\nAll other matrices are copied as-is.\n\nScalars and Per-gene:\n\nSame as in import_cells_h5ad!\n\nPer-cell:\n\nThe only properties we copy per cell are metacell_name (renamed to metacell with a default of the empty string), and similarly most_similar_name (renamed to most_similar.metacell, same default). That's the only reason we have a cells_h5ad parameter. You should therefore pass here the cells-with-metacells and not the clean cells h5ad.\n\nPer-metacell:\n\nThe metacells_level property is renamed to level.\nThe similar property is renamed to is_similar.\nThe type property is copied. If \"the\" type property of the metacells is different, use copy_data to rename it to type to match the Daf naming convention.\nAll other vectors are copied as-is.\n\nPer-metacell-per-metacell:\n\nThe obs_outgoing_weights matrix is renamed to outgoing_weights and always stored as Float32.\nAll other matrices are copied as-is.\n\nnote: Note\nIt is common to manually call reconstruct_type! on the result to create a type axis.\n\n\n\n\n\n","category":"function"},{"location":"anndata_format.html#Metacells.AnnDataFormat.reconstruct_type_axis!","page":"AnnData Format","title":"Metacells.AnnDataFormat.reconstruct_type_axis!","text":"reconstruct_type!(\n    daf::DafWriter,\n    base_axis::AbstractString = ```\"metacell\"```,\n    type_property::AbstractString = ```\"type\"```,\n    type_axis::AbstractString = ```\"type\"```,\n    empty_type::Maybe{AbstractString} = ```nothing```,\n    type_colors_csv::Maybe{AbstractString} = ```nothing```,\n    implicit_properties::Maybe{AbstractSet{<:AbstractString}} = ```nothing```,\n    skipped_properties::Maybe{AbstractSet{<:AbstractString}} = ```2 x Str (Set)```,\n    properties_defaults::Maybe{Dict} = ```nothing```,\n)::Nothing\n\nCreate a type axis after importing data containing type annotations. By default this will look for a type per metacell, but if you have type annotation per cell (which is not simply the type of the metacell they belong to), you can also use this for the cells.\n\nBy default this assumes that you have imported \"the\" type annotation to a property called \"type\", and that you would like the new type axis to be called \"type\" as well. If you want to import secondary types (or per-cell types), change these via the type_property and type_axis parameters.\n\nIf the type is equal to empty_type it is replaced with the empty string to match the Daf conventions for \"no value\" for string properties. Any set of per-gene properties named something_gene_of_type is converted to a per-gene-per-type matrix called is_something (with a default of false).\n\nOtherwise, this is mostly just a wrapper for reconstruct_axis!. It can be further enhanced by specifying a type_colors_csv file mapping type names to colors. This should be a comma or tab separated file containing at least two columns, one named \"color\" and one with the same name as the type_property. If this CSV file contains types that aren't actually used in the data, you will have to specify a default value for any other per-type property in properties_defaults.\n\nnote: Note\nMost metacells data has type annotations and colors associated with types, so it is highly recommended you invoke this to capture these into the Daf repository. This will enable all types (:-) of downstream processing, coloring graphs, etc.\n\n\n\n\n\n","category":"function"},{"location":"anndata_format.html#Metacells.AnnDataFormat.CopyAnnData","page":"AnnData Format","title":"Metacells.AnnDataFormat.CopyAnnData","text":"Specify how to copy data from AnnData to Daf. The key is simply a vector or matrix name (ignoring axes), and the value is either nothing to ignore the data, or a tuple with the name of the destination Daf property and an optional value to use for missing entries (raw-only cells and/or genes).\n\n\n\n\n\n","category":"type"},{"location":"anndata_format.html#Index","page":"AnnData Format","title":"Index","text":"","category":"section"},{"location":"anndata_format.html","page":"AnnData Format","title":"AnnData Format","text":"Pages = [\"anndata_format.md\"]","category":"page"},{"location":"compute_modules.html#Compute-Modules","page":"Compute Modules","title":"Compute Modules","text":"","category":"section"},{"location":"compute_modules.html#Metacells.ComputeModules","page":"Compute Modules","title":"Metacells.ComputeModules","text":"Group \"very correlated\" genes modules in each local environment.\n\n\n\n\n\n","category":"module"},{"location":"compute_modules.html#Metacells.ComputeModules.compute_blocks_modules!","page":"Compute Modules","title":"Metacells.ComputeModules.compute_blocks_modules!","text":"function compute_blocks_modules!(\n    daf::DafWriter;\n    min_module_downsampled_UMIs::Integer = ```8```,\n    min_module_strong_cells::Integer = ```12```,\n    min_merge_fragments_correlation::Real = ```0.5```,\n    min_merge_modules_correlation::Real = ```0.8```,\n    min_downsamples::Integer = ```750```,\n    min_downsamples_quantile::AbstractFloat = ```0.05```,\n    max_downsamples_quantile::AbstractFloat = ```0.5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nGroup the genes into modules based on their correlation.\n\nFor each block:\n\nCompute the correlation of the expression of the genes across all metacells in the block's environment.\nCluster the genes based on this correlation, using the :complete distance measure.\nBottom-up group genes into fragments and then into complete modules. Fragments have at least min_merge_fragments_correlation between all their genes. At some point, the fragment will contain enough genes so there will be at least min_module_strong_cells. A \"strong\" cell is expected to have at least min_module_downsampled_UMIs, if we downsample the cells in the environment using min_downsamples, min_downsamples_quantile, and max_downsamples_quantile. If the divergence is specified per gene, then it is applied to the UMIs. When this happens, we mark the fragment (which might be a single gene!) as a valid module. We will only merge two such modules if the correlation between all their genes is at least min_merge_modules_correlation.\nHaving merged some of the genes into modules, we repeat steps 2 and 3 for the unmerged genes until no new modules are found.\nMost of the genes will not end up in a valid module, and are given the module index 0. The other genes are given a 1-based module index. We need to store a matrix of module indices instead of module names due to Daf limitations (no matrices of strings).\n\nnote: Note\nThis uses the virtual metacell_gene_fraction_matrix. You will need an adapter to map these to concrete fractions (geomean, linear, scaled, ...). In addition, you might want to restrict the set of genes that are candidates to be included in the module, for example just to is_covered genes.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\ncell (required): Sequenced single cells.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\ncell @ metacell::AbstractString (required): The unique metacell each cell belongs to.\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\ngene @ divergence::Union{Float32, Float64} (optional): Scale fold factors of each gene by multiplying with (1 - divergence) of the gene.\n\nMatrices\n\ngene, cell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of UMIs collected for each gene for each cell.\n\ngene, metacell @ fraction::Union{Float32, Float64} (required): Some estimated fraction of the UMIs of each gene in each metacell.\n\nblock, gene @ isenvironmentmarker::Bool (required): A mask of genes that distinguish between cell states in each environment.\n\nblock, block @ isinenvironment::Bool (required): For each block, the (column) mask of nearby blocks in its expanded environment.\n\nOutputs\n\nAxes\n\nmodule (guaranteed): A local (per block) gene module.\n\nMatrices\n\nblock, gene @ module_index::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The index of the gene module each gene belongs to in the environment of each block.\n\nblock, module @ is_found::Bool (guaranteed): Whether each gene module is found in each block.\n\nblock, module @ mingenecorrelation::Union{Float32, Float64} (guaranteed): The minimal correlation between the genes of each gene module of each block.\n\n\n\n\n\n","category":"function"},{"location":"compute_modules.html#Index","page":"Compute Modules","title":"Index","text":"","category":"section"},{"location":"compute_modules.html","page":"Compute Modules","title":"Compute Modules","text":"Pages = [\"compute_blocks_modules.md\"]","category":"page"},{"location":"analyze_metacells.html#Analyze-Metacells","page":"Analyze Metacells","title":"Analyze Metacells","text":"","category":"section"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells","text":"Do simple metacells analysis.\n\n\n\n\n\n","category":"module"},{"location":"analyze_metacells.html#Counts","page":"Analyze Metacells","title":"Counts","text":"","category":"section"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_n_cells!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_n_cells!","text":"function compute_metacells_n_metacells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of metacells per metacell.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\ncell (required): Sequenced single cells.\n\nVectors\n\ncell @ metacell::AbstractString (required): The unique metacell each cell belongs to.\n\nOutputs\n\nVectors\n\nmetacell @ n_cells::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The number of cells in each metacell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#UMIs","page":"Analyze Metacells","title":"UMIs","text":"","category":"section"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_UMIs!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_UMIs!","text":"function compute_metacells_genes_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nInputs\n\nAxes\n\ncell (required): Sequenced single cells.\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ncell @ metacell::AbstractString (required): The unique metacell each cell belongs to.\n\nMatrices\n\ngene, cell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of UMIs collected for each gene for each cell.\n\nOutputs\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_total_UMIs!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_total_UMIs!","text":"function compute_metacells_total_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of UMIs used to estimate the fraction of all the genes in each metacell.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ is_excluded::Bool (required): A mask of genes that are totally excluded from the analysis.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nOutputs\n\nVectors\n\nmetacell @ total_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of UMIs used to estimate the fraction of all the genes in each metacell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_scaled_total_UMIs!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_scaled_total_UMIs!","text":"function compute_metacells_scaled_total_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of UMIs used to estimate the fraction of all the genes in each metacell, scaled by divergence.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ is_excluded::Bool (required): A mask of genes that are totally excluded from the analysis.\n\ngene @ divergence::Union{Float32, Float64} (required): Scale fold factors of each gene by multiplying with (1 - divergence) of the gene.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nOutputs\n\nVectors\n\nmetacell @ scaledtotalUMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of UMIs used to estimate the fraction of all the genes in each metacell, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_covered_UMIs!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_covered_UMIs!","text":"function compute_metacells_covered_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total UMIs of covered genes per metacell.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nOutputs\n\nVectors\n\nmetacell @ covered_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of the covered genes in each metacell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_scaled_covered_UMIs!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_scaled_covered_UMIs!","text":"function compute_metacells_scaled_covered_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total UMIs of covered genes per metacell, scaled by divergence.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ divergence::Union{Float32, Float64} (required): Scale fold factors of each gene by multiplying with (1 - divergence) of the gene.\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nOutputs\n\nVectors\n\nmetacell @ scaledcoveredUMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of the covered genes in each metacell, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Linear-Fractions","page":"Analyze Metacells","title":"Linear Fractions","text":"","category":"section"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_linear_fractions!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_linear_fractions!","text":"function compute_metacells_genes_linear_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nAn estimated linear fraction of the UMIs of each gene in each metacell. This is just the total UMIs of the gene in the metacell divided by the total UMIs of the metacell, which is the \"best\" estimate assuming multinomial sampling noise. However, this is sensitive to a few cells with very high expression levels (\"bursty\" genes).\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ is_excluded::Bool (required): A mask of genes that are totally excluded from the analysis.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nOutputs\n\nMatrices\n\ngene, metacell @ linear_fraction::Union{Float32, Float64} (guaranteed): The estimated linear fraction of the UMIs of each gene in each metacell, out of the total UMIs.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_scaled_linear_fractions!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_scaled_linear_fractions!","text":"function compute_metacells_genes_scaled_linear_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe estimated linear fraction of the UMIs of each gene in each metacell, scaled by divergence. We apply this scaling to reduce the disproportionate impact of highly variable (\"bursty\") genes when using square-error methods.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ divergence::Union{Float32, Float64} (required): Scale fold factors of each gene by multiplying with (1 - divergence) of the gene.\n\nMatrices\n\ngene, metacell @ linear_fraction::Union{Float32, Float64} (required): The estimated linear fraction of the UMIs of each gene in each metacell, out of the total UMIs.\n\nOutputs\n\nMatrices\n\ngene, metacell @ scaledlinearfraction::Union{Float32, Float64} (guaranteed): The estimated linear fraction of the UMIs of each gene in each metacell, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_log_linear_fractions!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_log_linear_fractions!","text":"function compute_metacells_genes_log_linear_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe log base 2 of the estimated linear fraction of the UMIs of each gene in each metacell. This adds the gene_fraction_regularization to deal with zero fractions.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nMatrices\n\ngene, metacell @ linear_fraction::Union{Float32, Float64} (required): The estimated linear fraction of the UMIs of each gene in each metacell, out of the total UMIs.\n\nOutputs\n\nMatrices\n\ngene, metacell @ loglinearfraction::Union{Float32, Float64} (guaranteed): The log base 2 of the estimated linear fraction of the UMIs of each gene in each metacell, out of the total UMIs.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_log_scaled_linear_fractions!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_log_scaled_linear_fractions!","text":"function compute_metacells_genes_log_scaled_linear_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe estimated linear fraction of the UMIs of each gene in each metacell, scaled by divergence. We apply this scaling to reduce the disproportionate impact of highly variable (\"bursty\") genes when using square-error methods.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nMatrices\n\ngene, metacell @ scaledlinearfraction::Union{Float32, Float64} (required): The estimated linear fraction of the UMIs of each gene in each metacell, scaled by divergence.\n\nOutputs\n\nMatrices\n\ngene, metacell @ logscaledlinear_fraction::Union{Float32, Float64} (guaranteed): The log base 2 of the scaled estimated linear fraction of the UMIs of each gene in each metacell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Linear-Covered-Fractions","page":"Analyze Metacells","title":"Linear Covered Fractions","text":"","category":"section"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_linear_covered_fractions!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_linear_covered_fractions!","text":"function compute_metacells_genes_linear_covered_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nAn estimated linear fraction of the UMIs of each covered gene in each metacell. By considering only the covered genes this avoid the impact of highly-expressed lateral genes (e.g., cell cycle). Otherwise is similar to compute_metacells_genes_linear_fractions!.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nOutputs\n\nMatrices\n\ngene, metacell @ linearcoveredfraction::Union{Float32, Float64} (guaranteed): The estimated linear fraction of the UMIs of each covered gene in each metacell, out of the total covered UMIs.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_scaled_linear_covered_fractions!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_scaled_linear_covered_fractions!","text":"function compute_metacells_genes_scaled_linear_covered_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe estimated linear fraction of the UMIs of each covered gene in each metacell, scaled by divergence. We apply this scaling to reduce the disproportionate impact of highly variable (\"bursty\") genes when using square-error methods.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ divergence::Union{Float32, Float64} (required): Scale fold factors of each gene by multiplying with (1 - divergence) of the gene.\n\nMatrices\n\ngene, metacell @ linearcoveredfraction::Union{Float32, Float64} (required): The estimated linear fraction of the UMIs of each covered gene in each metacell, out of the total covered UMIs.\n\nOutputs\n\nMatrices\n\ngene, metacell @ scaledlinearcovered_fraction::Union{Float32, Float64} (guaranteed): The estimated linear fraction of the UMIs of each gene in each metacell, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_log_linear_covered_fractions!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_log_linear_covered_fractions!","text":"function compute_metacells_genes_log_linear_covered_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe log base 2 of the estimated linear fraction of the UMIs of each covered gene in each metacell. This adds the gene_fraction_regularization to deal with zero fractions.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nMatrices\n\ngene, metacell @ linearcoveredfraction::Union{Float32, Float64} (required): The estimated linear fraction of the UMIs of each covered gene in each metacell, out of the total covered UMIs.\n\nOutputs\n\nMatrices\n\ngene, metacell @ loglinearcovered_fraction::Union{Float32, Float64} (guaranteed): The log base 2 of the estimated linear fraction of the UMIs of each covered gene in each metacell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_log_scaled_linear_covered_fractions!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_log_scaled_linear_covered_fractions!","text":"function compute_metacells_genes_log_scaled_linear_covered_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe estimated linear fraction of the UMIs of each covered gene in each metacell, scaled by divergence. We apply this scaling to reduce the disproportionate impact of highly variable (\"bursty\") genes when using square-error methods.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nMatrices\n\ngene, metacell @ scaledlinearcovered_fraction::Union{Float32, Float64} (required): The estimated linear fraction of the UMIs of each gene in each metacell, scaled by divergence.\n\nOutputs\n\nMatrices\n\ngene, metacell @ logscaledlinearcoveredfraction::Union{Float32, Float64} (guaranteed): The log base 2 of the estimated linear fraction of the UMIs of each covered gene in each metacell, out of the total covered UMIs, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Geomean-Fractions","page":"Analyze Metacells","title":"Geomean Fractions","text":"","category":"section"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_geomean_fractions!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_geomean_fractions!","text":"compute_metacells_genes_geomean_fractions!(\n    daf::DafWriter;\n    UMIs_regularization::AbstractFloat = ```0.0625```,\n    min_downsamples::Integer = ```750```,\n    min_downsamples_quantile::AbstractFloat = ```0.05```,\n    max_downsamples_quantile::AbstractFloat = ```0.5```,\n    rng::AbstractRNG = default_rng(),\n    overwrite::Bool = ```false```,\n)::Nothing\n\nGiven an assignment of cells to metacell, compute an geomean estimation of the fraction of UMIs of each gene for each metacell.\n\nThe linear way to do this would be to just take the total UMIs of the gene out of the total UMIs of the metacell. However, this method has a weakness; a single strong cell with a \"very different\" fraction of the gene will dominate (that is, the method is sensitive to outliers).\n\nInstead, we take the geometric mean of the fractions of the gene in the cells. This however raises a few issues we need to deal with:\n\nGenes with zero UMIs are a problem; to combat this, we add a UMIs_regularization factor when computing the fractions, take the geomean, and subtract the regularization at the end (so all-zero genes will still get a zero overall fraction).\nWe want to give more weight to cells with more UMIs, so we use a scaled geomean. The weight we give to each cell is the log of the total number of UMIs in it.\nThe geomean fractions of all the genes in a metacell do not sum to one, so we scale them. This has the unfortunate side effect that the end result does not obey a nice relation to the linear fraction of the gene in each of the cells; in particular, the final result might be higher than all of these per-cell fractions (ouch).\n\nThis raises an important point about the whole \"fraction of UMIs of a gene in a cell\" concept, which is that it is highly dependent on the set of genes you pick to compute the fraction out of (that is, the denominator). This places restrictions on how you should use these fractions:\n\nYou can't just compare these fractions between two arbitrary data sets, as the denominators aren't the same. You must identify the set of common genes, and renormalize the fractions to sum to one in this subset, in both data sets. Only then can you meaningfully compare the results.\nEven if you compare two data sets with the same set of genes (or even two subsets of the same data set, such as two \"cell types\"), if a specific \"gene program\" has a very high total expression in only one of them, then all other genes will artificially appear to be lower.\nThis is why we recommend excluding ribosomal genes from the data sets; they can take up anything between almost none to over two thirds of the total UMIs, and this varies between \"cell types\". This means that if they are included in the denominator, the fractions of otherwise \"identical\" genes will appear to differ by a factor of up to 3X\nLuckily, most gene programs we deal with have a total expression of a few percent at most, so this effect is negligible. However if you identify a gene program with a total expression higher than, say, 10%, you should consider its effect on the rest of the genes.\n\nInputs\n\nAxes\n\ncell (required): Sequenced single cells.\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ngene @ is_excluded::Bool (required): A mask of genes that are totally excluded from the analysis.\n\ncell @ total_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs of all the genes in each cell.\n\ncell @ metacell::AbstractString (required): The unique metacell each cell belongs to.\n\nMatrices\n\ngene, cell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of UMIs collected for each gene for each cell.\n\nOutputs\n\nMatrices\n\ngene, metacell @ geomean_fraction::Union{Float32, Float64} (guaranteed): The estimated geomean fraction of the UMIs of each gene in each metacell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_genes_log_geomean_fractions!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_genes_log_geomean_fractions!","text":"function compute_metacells_genes_log_geomean_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe log base 2 of the estimated geomean fraction of the UMIs of each gene in each metacell. This adds the gene_fraction_regularization to deal with zero fractions.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nMatrices\n\ngene, metacell @ geomean_fraction::Union{Float32, Float64} (required): The estimated geomean fraction of the UMIs of each gene in each metacell.\n\nOutputs\n\nMatrices\n\ngene, metacell @ loggeomeanfraction::Union{Float32, Float64} (guaranteed): The log base 2 of the estimated geomean fraction of the UMIs of each gene in each metacell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Likelihoods","page":"Analyze Metacells","title":"Likelihoods","text":"","category":"section"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_cells_linear_metacell_cross_entropy!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_cells_linear_metacell_cross_entropy!","text":"compute_cells_linear_metacell_cross_entropy!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = GENE_FRACTION_REGULARIZATION,\n    overwrite::Bool = false,\n)::Nothing\n\nTODOX\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_cells_linear_covered_metacell_cross_entropy!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_cells_linear_covered_metacell_cross_entropy!","text":"compute_cells_linear_covered_metacell_cross_entropy!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = GENE_FRACTION_REGULARIZATION\n    overwrite::Bool = false,\n)::Nothing\n\nTODOX\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_mean_cells_linear_cross_entropy!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_mean_cells_linear_cross_entropy!","text":"compute_metacells_mean_cells_linear_cross_entropy!(daf::DafWriter; overwrite::Bool = false)::Nothing\n\nTODOX\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_mean_cells_linear_covered_cross_entropy!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_mean_cells_linear_covered_cross_entropy!","text":"compute_metacells_mean_cells_linear_covered_cross_entropy!(daf::DafWriter; overwrite::Bool = false)::Nothing\n\nTODOX\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_cells_linear_metacell_kl_divergence!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_cells_linear_metacell_kl_divergence!","text":"compute_cells_linear_metacell_kl_divergence!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = GENE_FRACTION_REGULARIZATION,\n    overwrite::Bool = false,\n)::Nothing\n\nTODOX\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_cells_linear_covered_metacell_kl_divergence!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_cells_linear_covered_metacell_kl_divergence!","text":"compute_cells_linear_covered_metacell_kl_divergence!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = GENE_FRACTION_REGULARIZATION\n    overwrite::Bool = false,\n)::Nothing\n\nTODOX\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_mean_cells_linear_kl_divergence!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_mean_cells_linear_kl_divergence!","text":"compute_metacells_mean_cells_linear_kl_divergence!(daf::DafWriter; overwrite::Bool = false)::Nothing\n\nTODOX\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_mean_cells_linear_covered_kl_divergence!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_mean_cells_linear_covered_kl_divergence!","text":"compute_metacells_mean_cells_linear_covered_kl_divergence!(daf::DafWriter; overwrite::Bool = false)::Nothing\n\nTODOX\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Types","page":"Analyze Metacells","title":"Types","text":"","category":"section"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_cells_types_by_metacells!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_cells_types_by_metacells!","text":"function compute_cells_types_by_metacells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe type of each cell, based on the type of the metacell it belongs to.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\ncell (required): Sequenced single cells.\n\nVectors\n\ncell @ metacell::AbstractString (required): The unique metacell each cell belongs to.\n\nmetacell @ type::AbstractString (required): The type each metacell belongs to.\n\nOutputs\n\nVectors\n\ncell @ type::AbstractString (guaranteed): The type each cell belongs to.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Metacells.AnalyzeMetacells.compute_metacells_types_by_cells!","page":"Analyze Metacells","title":"Metacells.AnalyzeMetacells.compute_metacells_types_by_cells!","text":"function compute_metacells_types_by_cells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe type of each metacell, based on is cell types. This assumes that each cell was assigned type, either because we imported the data from a cell-based atlas, or from previous computed metacells.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\ncell (required): Sequenced single cells.\n\nVectors\n\ncell @ metacell::AbstractString (required): The unique metacell each cell belongs to.\n\ncell @ type::AbstractString (required): The type each cell belongs to.\n\nOutputs\n\nVectors\n\nmetacell @ type::AbstractString (guaranteed): The type each metacell belongs to.\n\n\n\n\n\n","category":"function"},{"location":"analyze_metacells.html#Index","page":"Analyze Metacells","title":"Index","text":"","category":"section"},{"location":"analyze_metacells.html","page":"Analyze Metacells","title":"Analyze Metacells","text":"Pages = [\"analyze_metacells.md\"]","category":"page"},{"location":"analyze_blocks.html#Analyze-Blocks","page":"Analyze Blocks","title":"Analyze Blocks","text":"","category":"section"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks","text":"Do simple blocks analysis.\n\n\n\n\n\n","category":"module"},{"location":"analyze_blocks.html#Counts","page":"Analyze Blocks","title":"Counts","text":"","category":"section"},{"location":"analyze_blocks.html#Cells","page":"Analyze Blocks","title":"Cells","text":"","category":"section"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_n_cells!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_n_cells!","text":"function compute_blocks_n_cells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of cells per block.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\nmetacell @ n_cells::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of cells in each metacell.\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nOutputs\n\nVectors\n\nblock @ n_cells::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The number of cells in the metacells in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_n_neighborhood_cells!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_n_neighborhood_cells!","text":"function compute_blocks_n_neighborhood_cells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of cells in the metacells of the blocks of the neighborhood centered at a block.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\nmetacell @ n_cells::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of cells in each metacell.\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\nblock, block @ isinneighborhood::Bool (required): For each block, the (column) mask of nearby blocks in its immediate neighborhood.\n\nOutputs\n\nVectors\n\nblock @ nneighborhoodcells::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of cells in the metacells in the blocks of the neighborhood centered at each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_n_environment_cells!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_n_environment_cells!","text":"function compute_blocks_n_environment_cells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of cells in the metacells of the blocks of the environment centered at each block.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\nmetacell @ n_cells::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of cells in each metacell.\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\nblock, block @ isinenvironment::Bool (required): For each block, the (column) mask of nearby blocks in its expanded environment.\n\nOutputs\n\nVectors\n\nblock @ nenvironmentcells::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of cells in the metacells in the blocks of the environment centered at each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells","page":"Analyze Blocks","title":"Metacells","text":"","category":"section"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_n_metacells!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_n_metacells!","text":"function compute_blocks_n_metacells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of metacells per block.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nOutputs\n\nVectors\n\nblock @ n_metacells::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The number of metacells in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_n_neighborhood_metacells!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_n_neighborhood_metacells!","text":"function compute_blocks_n_neighborhood_metacells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of metacells in the blocks of the neighborhood centered at each block.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\nblock, block @ isinneighborhood::Bool (required): For each block, the (column) mask of nearby blocks in its immediate neighborhood.\n\nOutputs\n\nVectors\n\nblock @ nneighborhoodmetacells::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of metacells in the blocks of the neighborhood centered at each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_n_environment_metacells!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_n_environment_metacells!","text":"function compute_blocks_n_environment_metacells!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of metacells in the blocks of the environment centered at each block.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\nblock, block @ isinenvironment::Bool (required): For each block, the (column) mask of nearby blocks in its expanded environment.\n\nOutputs\n\nVectors\n\nblock @ nenvironmentmetacells::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of metacells in the blocks of the environment centered at each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Blocks","page":"Analyze Blocks","title":"Blocks","text":"","category":"section"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_n_neighborhood_blocks!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_n_neighborhood_blocks!","text":"function compute_blocks_n_neighborhood_blocks!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of blocks in the neighborhood centered at each block.\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nMatrices\n\nblock, block @ isinneighborhood::Bool (required): For each block, the (column) mask of nearby blocks in its immediate neighborhood.\n\nOutputs\n\nVectors\n\nblock @ nneighborhoodblocks::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of blocks in the neighborhood centered at each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_n_environment_blocks!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_n_environment_blocks!","text":"function compute_blocks_n_environment_blocks!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of blocks in the environment centered at each block.\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nMatrices\n\nblock, block @ isinenvironment::Bool (required): For each block, the (column) mask of nearby blocks in its expanded environment.\n\nOutputs\n\nVectors\n\nblock @ nenvironmentblocks::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of blocks in the environment centered at each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#UMIs","page":"Analyze Blocks","title":"UMIs","text":"","category":"section"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_genes_UMIs!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_genes_UMIs!","text":"function compute_blocks_genes_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total number of UMIs used to estimate the fraction of each gene in each block. This can used to estimate the robustness of the fraction.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nOutputs\n\nMatrices\n\ngene, block @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of UMIs used to estimate the fraction of each gene in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_total_UMIs!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_total_UMIs!","text":"function compute_blocks_total_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total UMIs of genes per block.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nMatrices\n\ngene, block @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each block.\n\nOutputs\n\nVectors\n\nblock @ total_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of UMIs used to estimate the fraction of all the genes in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_scaled_total_UMIs!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_scaled_total_UMIs!","text":"function compute_blocks_scaled_total_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total UMIs of genes per block, scaled by divergence.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\ngene @ divergence::Union{Float32, Float64} (required): Scale fold factors of each gene by multiplying with (1 - divergence) of the gene.\n\nMatrices\n\ngene, block @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each block.\n\nOutputs\n\nVectors\n\nblock @ scaledtotalUMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of UMIs used to estimate the fraction of all the genes in each block, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_covered_UMIs!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_covered_UMIs!","text":"function compute_blocks_covered_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total UMIs of covered genes per block.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\nMatrices\n\ngene, block @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each block.\n\nOutputs\n\nVectors\n\nblock @ covered_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of the covered genes in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_scaled_covered_UMIs!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_scaled_covered_UMIs!","text":"function compute_blocks_scaled_covered_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total UMIs of covered genes per block, scaled by divergence.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\ngene @ divergence::Union{Float32, Float64} (required): Scale fold factors of each gene by multiplying with (1 - divergence) of the gene.\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\nMatrices\n\ngene, block @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each block.\n\nOutputs\n\nVectors\n\nblock @ scaledcoveredUMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total number of the covered genes in each block, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Fractions","page":"Analyze Blocks","title":"Fractions","text":"","category":"section"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_genes_linear_fractions!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_genes_linear_fractions!","text":"function compute_blocks_genes_linear_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nAn estimated linear fraction of the UMIs of each gene in each block. This is just the total UMIs of the gene in the metacell divided by the total UMIs of the metacell, which is the \"best\" estimate assuming multinomial sampling noise. However, this is sensitive to a few metacells with very high expression levels (\"bursty\" genes).\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\ngene @ is_excluded::Bool (required): A mask of genes that are totally excluded from the analysis.\n\nMatrices\n\ngene, block @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each block.\n\nOutputs\n\nMatrices\n\ngene, block @ linear_fraction::Union{Float32, Float64} (guaranteed): The estimated linear fraction of the UMIs of each gene out of the total UMIs in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_genes_scaled_linear_fractions!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_genes_scaled_linear_fractions!","text":"function compute_blocks_genes_scaled_linear_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe estimated linear fraction of the UMIs of each gene in each block, scaled by divergence. We apply this scaling to reduce the disproportionate impact of highly variable (\"bursty\") genes when using square-error methods.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\ngene @ divergence::Union{Float32, Float64} (required): Scale fold factors of each gene by multiplying with (1 - divergence) of the gene.\n\nMatrices\n\ngene, block @ linear_fraction::Union{Float32, Float64} (required): The estimated linear fraction of the UMIs of each gene out of the total UMIs in each block.\n\nOutputs\n\nMatrices\n\ngene, block @ scaledlinearfraction::Union{Float32, Float64} (guaranteed): The estimated linear fraction of the UMIs of each gene out of the total UMIs in each block, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_genes_log_linear_fractions!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_genes_log_linear_fractions!","text":"function compute_blocks_genes_log_linear_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe log base 2 of the estimated linear fraction of the UMIs of each gene in each block. This adds the gene_fraction_regularization to deal with zero fractions.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nMatrices\n\ngene, block @ linear_fraction::Union{Float32, Float64} (required): The estimated linear fraction of the UMIs of each gene out of the total UMIs in each block.\n\nOutputs\n\nMatrices\n\ngene, block @ loglinearfraction::Union{Float32, Float64} (guaranteed): The log base 2 of the estimated linear fraction of the UMIs of each gene out of the total UMIs in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_genes_log_scaled_linear_fractions!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_genes_log_scaled_linear_fractions!","text":"function compute_blocks_genes_log_scaled_linear_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe estimated linear fraction of the UMIs of each gene in each block, scaled by divergence. We apply this scaling to reduce the disproportionate impact of highly variable (\"bursty\") genes when using square-error methods.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nMatrices\n\ngene, block @ scaledlinearfraction::Union{Float32, Float64} (required): The estimated linear fraction of the UMIs of each gene out of the total UMIs in each block, scaled by divergence.\n\nOutputs\n\nMatrices\n\ngene, block @ logscaledlinear_fraction::Union{Float32, Float64} (guaranteed): The log base 2 of the scaled estimated linear fraction of the UMIs of each gene out of the total UMIs in each block, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_genes_linear_covered_fractions!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_genes_linear_covered_fractions!","text":"function compute_blocks_genes_linear_covered_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nAn estimated linear fraction of the UMIs of each covered gene in each block. By considering only the covered genes this avoid the impact of highly-expressed lateral genes (e.g., cell cycle). Otherwise is similar to compute_blocks_genes_linear_fractions!.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\nMatrices\n\ngene, block @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each block.\n\nOutputs\n\nMatrices\n\ngene, block @ linearcoveredfraction::Union{Float32, Float64} (guaranteed): The estimated linear fraction of the UMIs of each covered gene out of the total covered UMIs in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_genes_scaled_linear_covered_fractions!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_genes_scaled_linear_covered_fractions!","text":"function compute_blocks_genes_scaled_linear_covered_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe estimated linear fraction of the UMIs of each covered gene in each block, scaled by divergence. We apply this scaling to reduce the disproportionate impact of highly variable (\"bursty\") genes when using square-error methods.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\ngene @ divergence::Union{Float32, Float64} (required): Scale fold factors of each gene by multiplying with (1 - divergence) of the gene.\n\nMatrices\n\ngene, block @ linearcoveredfraction::Union{Float32, Float64} (required): The estimated linear fraction of the UMIs of each covered gene out of the total covered UMIs in each block.\n\nOutputs\n\nMatrices\n\ngene, block @ scaledlinearcovered_fraction::Union{Float32, Float64} (guaranteed): The estimated linear fraction of the UMIs of each covered gene out of the total covered UMIs in each block, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_genes_log_linear_covered_fractions!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_genes_log_linear_covered_fractions!","text":"function compute_blocks_genes_log_linear_covered_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe log base 2 of the estimated linear fraction of the UMIs of each covered gene in each block. This adds the gene_fraction_regularization to deal with zero fractions.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nMatrices\n\ngene, block @ linearcoveredfraction::Union{Float32, Float64} (required): The estimated linear fraction of the UMIs of each covered gene out of the total covered UMIs in each block.\n\nOutputs\n\nMatrices\n\ngene, block @ loglinearcovered_fraction::Union{Float32, Float64} (guaranteed): The log base 2 of the estimated linear fraction of the UMIs of each covered gene out of the total covered UMIs in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_genes_log_scaled_linear_covered_fractions!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_genes_log_scaled_linear_covered_fractions!","text":"function compute_blocks_genes_log_scaled_linear_covered_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe estimated linear fraction of the UMIs of each covered gene in each block, scaled by divergence. We apply this scaling to reduce the disproportionate impact of highly variable (\"bursty\") genes when using square-error methods.\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nMatrices\n\ngene, block @ scaledlinearcovered_fraction::Union{Float32, Float64} (required): The estimated linear fraction of the UMIs of each covered gene out of the total covered UMIs in each block, scaled by divergence.\n\nOutputs\n\nMatrices\n\ngene, block @ logscaledlinearcoveredfraction::Union{Float32, Float64} (guaranteed): The log base 2 of the scaled estimated linear fraction of the UMIs of each covered gene out of the total covered UMIs in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Genes","page":"Analyze Blocks","title":"Genes","text":"","category":"section"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_genes_is_neighborhood_markers!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_genes_is_neighborhood_markers!","text":"compute_blocks_genes_is_neighborhood_markers!(\n    daf::DafWriter;\n    min_marker_gene_max_fraction::AbstractFloat = ```0.0001```,\n    min_marker_gene_range_fold::Real = ```2```,\n    overwrite::Bool = false,\n)::Nothing\n\nA mask of genes that distinguish between cell states in each neighborhood. Otherwise similar to identify_marker_genes!.\n\nnote: Note\nThis uses the virtual metacell_gene_fraction_matrix and metacell_gene_log_fraction_matrix. You will need an adapter to map these to concrete fractions (geomean, linear, scaled, ...). Make sure you are consistent when mapping the fractions and log-fraction matrices.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_genes_is_environment_markers!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_genes_is_environment_markers!","text":"compute_blocks_genes_is_environment_markers!(\n    daf::DafWriter;\n    min_marker_gene_max_fraction::AbstractFloat = ```0.0001```,\n    min_marker_gene_range_fold::Real = ```2```,\n    overwrite::Bool = false,\n)::Nothing\n\nA mask of genes that distinguish between cell states in each environment. Otherwise similar to identify_marker_genes!.\n\nnote: Note\nThis uses the virtual metacell_gene_fraction_matrix and metacell_gene_log_fraction_matrix. You will need an adapter to map these to concrete fractions (geomean, linear, scaled, ...). Make sure you are consistent when mapping the fractions and log-fraction matrices.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Metadata","page":"Analyze Blocks","title":"Metadata","text":"","category":"section"},{"location":"analyze_blocks.html#Metacells.AnalyzeBlocks.compute_blocks_types!","page":"Analyze Blocks","title":"Metacells.AnalyzeBlocks.compute_blocks_types!","text":"function compute_blocks_types!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe type of each block, based on is metacell types.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nVectors\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nmetacell @ type::AbstractString (required): The type each metacell belongs to.\n\nOutputs\n\nVectors\n\nblock @ type::AbstractString (guaranteed): The type each block belongs to.\n\n\n\n\n\n","category":"function"},{"location":"analyze_blocks.html#Index","page":"Analyze Blocks","title":"Index","text":"","category":"section"},{"location":"analyze_blocks.html","page":"Analyze Blocks","title":"Analyze Blocks","text":"Pages = [\"analyze_blocks.md\"]","category":"page"},{"location":"analyze_modules.html#Analyze-Modules","page":"Analyze Modules","title":"Analyze Modules","text":"","category":"section"},{"location":"analyze_modules.html#Metacells.AnalyzeModules","page":"Analyze Modules","title":"Metacells.AnalyzeModules","text":"Do simple gene module analysis.\n\n\n\n\n\n","category":"module"},{"location":"analyze_modules.html#Counts","page":"Analyze Modules","title":"Counts","text":"","category":"section"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_blocks_modules_n_genes!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_blocks_modules_n_genes!","text":"function compute_blocks_modules_n_genes!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe number of genes in each gene module in each block.\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nmodule (required): A local (per block) gene module.\n\ngene (required): Sequenced genes.\n\nMatrices\n\nblock, gene @ module_index::Union{UInt16, UInt32, UInt64, UInt8} (required): The index of the gene module each gene belongs to in the environment of each block.\n\nOutputs\n\nMatrices\n\nblock, module @ n_genes::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The number of genes in each gene module in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_blocks_modules_n_covered!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_blocks_modules_n_covered!","text":"function compute_blocks_modules_n_covered!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe number of covered genes in each gene module in each block.\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nmodule (required): A local (per block) gene module.\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\nMatrices\n\nblock, gene @ module_index::Union{UInt16, UInt32, UInt64, UInt8} (required): The index of the gene module each gene belongs to in the environment of each block.\n\nOutputs\n\nMatrices\n\nblock, module @ n_covered::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The number of covered genes in each gene module in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_blocks_n_found_modules!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_blocks_n_found_modules!","text":"function compute_blocks_n_found_modules!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe number of found gene modules for each block.\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nmodule (required): A local (per block) gene module.\n\nMatrices\n\nblock, module @ is_found::Bool (required): Whether each gene module is found in each block.\n\nOutputs\n\nVectors\n\nblock @ nfoundmodules::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The number of found modules for each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_blocks_n_used_modules!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_blocks_n_used_modules!","text":"function compute_blocks_n_used_modules!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe number of used gene modules for each block.\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nmodule (required): A local (per block) gene module.\n\nMatrices\n\nblock, module @ is_used::Bool (required): Whether each gene module is used in the linear model of each block.\n\nOutputs\n\nVectors\n\nblock @ nusedmodules::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The number of used modules for each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Masks","page":"Analyze Modules","title":"Masks","text":"","category":"section"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_blocks_modules_is_used!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_blocks_modules_is_used!","text":"function compute_blocks_modules_is_used!(\n    daf::DafWriter;\n    min_used_module_covered_UMIs_fraction::Real = ```0.67```,\n    overwrite::Bool = ```false```,\n)::Nothing\n\nWhether each gene module is used by each block. We only use modules that have a high fraction of covered gene UMIs (specifically, at least min_used_module_covered_UMIs_fraction).\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nmodule (required): A local (per block) gene module.\n\nMatrices\n\nblock, module @ covered_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total UMIs of the covered genes in each gene module in each block.\n\nblock, module @ total_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total UMIs of the genes in each gene module in each block.\n\nOutputs\n\nMatrices\n\nblock, module @ is_used::Bool (guaranteed): Whether each gene module is used in the linear model of each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#UMIs","page":"Analyze Modules","title":"UMIs","text":"","category":"section"},{"location":"analyze_modules.html#Modules","page":"Analyze Modules","title":"Modules","text":"","category":"section"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_metacells_modules_total_UMIs!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_metacells_modules_total_UMIs!","text":"function compute_metacells_modules_total_UMIs!(daf::DafWriter; overwrite::Bool = false)::Nothing\n\nThe total UMIs of the genes of each module in each metacell.\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nmodule (required): A local (per block) gene module.\n\ngene (required): Sequenced genes.\n\nVectors\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nblock, gene @ module_index::Union{UInt16, UInt32, UInt64, UInt8} (required): The index of the gene module each gene belongs to in the environment of each block.\n\nOutputs\n\nMatrices\n\nmetacell, module @ total_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total UMIs of the genes of each module in each metacell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_metacells_modules_scaled_total_UMIs!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_metacells_modules_scaled_total_UMIs!","text":"function compute_metacells_modules_scaled_total_UMIs!(daf::DafWriter; overwrite::Bool = false)::Nothing\n\nThe total UMIs of the genes of each module in each metacell, scaled by divergence.\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nmodule (required): A local (per block) gene module.\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ divergence::Union{Float32, Float64} (required): Scale fold factors of each gene by multiplying with (1 - divergence) of the gene.\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nblock, gene @ module_index::Union{UInt16, UInt32, UInt64, UInt8} (required): The index of the gene module each gene belongs to in the environment of each block.\n\nOutputs\n\nMatrices\n\nmetacell, module @ scaledtotalUMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total UMIs of the genes of each module in each metacell, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_metacells_modules_covered_UMIs!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_metacells_modules_covered_UMIs!","text":"function compute_metacells_modules_covered_UMIs!(daf::DafWriter; overwrite::Bool = false)::Nothing\n\nThe total UMIs of the covered genes of each module in each metacell.\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nmodule (required): A local (per block) gene module.\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nblock, gene @ module_index::Union{UInt16, UInt32, UInt64, UInt8} (required): The index of the gene module each gene belongs to in the environment of each block.\n\nOutputs\n\nMatrices\n\nmetacell, module @ covered_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total UMIs of the covered genes of each module in each metacell.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_metacells_modules_scaled_covered_UMIs!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_metacells_modules_scaled_covered_UMIs!","text":"function compute_metacells_modules_scaled_covered_UMIs!(daf::DafWriter; overwrite::Bool = false)::Nothing\n\nThe total UMIs of the covered genes of each module in each metacell, scaled by divergence.\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nmodule (required): A local (per block) gene module.\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ divergence::Union{Float32, Float64} (required): Scale fold factors of each gene by multiplying with (1 - divergence) of the gene.\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nblock, gene @ module_index::Union{UInt16, UInt32, UInt64, UInt8} (required): The index of the gene module each gene belongs to in the environment of each block.\n\nOutputs\n\nMatrices\n\nmetacell, module @ scaledcoveredUMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total UMIs of the covered genes of each module in each metacell, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Blocks","page":"Analyze Modules","title":"Blocks","text":"","category":"section"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_blocks_modules_total_UMIs!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_blocks_modules_total_UMIs!","text":"function compute_blocks_modules_total_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total UMIs of the genes in each gene module in each block.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nmodule (required): A local (per block) gene module.\n\ngene (required): Sequenced genes.\n\nVectors\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nblock, block @ isinenvironment::Bool (required): For each block, the (column) mask of nearby blocks in its expanded environment.\n\nblock, gene @ module_index::Union{UInt16, UInt32, UInt64, UInt8} (required): The index of the gene module each gene belongs to in the environment of each block.\n\nOutputs\n\nMatrices\n\nblock, module @ total_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total UMIs of the genes in each gene module in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_blocks_modules_covered_UMIs!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_blocks_modules_covered_UMIs!","text":"function compute_blocks_modules_covered_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total UMIs of the covered genes in each gene module in each block.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nmodule (required): A local (per block) gene module.\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nblock, block @ isinenvironment::Bool (required): For each block, the (column) mask of nearby blocks in its expanded environment.\n\nblock, gene @ module_index::Union{UInt16, UInt32, UInt64, UInt8} (required): The index of the gene module each gene belongs to in the environment of each block.\n\nOutputs\n\nMatrices\n\nblock, module @ covered_UMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total UMIs of the covered genes in each gene module in each block.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_blocks_modules_scaled_total_UMIs!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_blocks_modules_scaled_total_UMIs!","text":"function compute_blocks_modules_scaled_total_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total UMIs of the genes in each gene module in each block, scaled by divergence.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nmodule (required): A local (per block) gene module.\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ divergence::Union{Float32, Float64} (required): Scale fold factors of each gene by multiplying with (1 - divergence) of the gene.\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nblock, block @ isinenvironment::Bool (required): For each block, the (column) mask of nearby blocks in its expanded environment.\n\nblock, gene @ module_index::Union{UInt16, UInt32, UInt64, UInt8} (required): The index of the gene module each gene belongs to in the environment of each block.\n\nOutputs\n\nMatrices\n\nblock, module @ scaledtotalUMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total UMIs of the genes in each gene module in each bloc, scaled by divergence..\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_blocks_modules_scaled_covered_UMIs!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_blocks_modules_scaled_covered_UMIs!","text":"function compute_blocks_modules_scaled_covered_UMIs!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe total UMIs of the covered genes in each gene module in each block, scaled by divergence.\n\nInputs\n\nAxes\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nmodule (required): A local (per block) gene module.\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ divergence::Union{Float32, Float64} (required): Scale fold factors of each gene by multiplying with (1 - divergence) of the gene.\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\ngene, metacell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The total number of UMIs used to estimate the fraction of each gene in each metacell.\n\nblock, block @ isinenvironment::Bool (required): For each block, the (column) mask of nearby blocks in its expanded environment.\n\nblock, gene @ module_index::Union{UInt16, UInt32, UInt64, UInt8} (required): The index of the gene module each gene belongs to in the environment of each block.\n\nOutputs\n\nMatrices\n\nblock, module @ scaledcoveredUMIs::Union{UInt16, UInt32, UInt64, UInt8} (guaranteed): The total UMIs of the covered genes in each gene module in each block, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Fractions","page":"Analyze Modules","title":"Fractions","text":"","category":"section"},{"location":"analyze_modules.html#Modules-2","page":"Analyze Modules","title":"Modules","text":"","category":"section"},{"location":"analyze_modules.html#Linear-Fractions","page":"Analyze Modules","title":"Linear Fractions","text":"","category":"section"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_metacells_modules_linear_fractions!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_metacells_modules_linear_fractions!","text":"function compute_metacells_modules_linear_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = false,\n)::Nothing\n\nThe estimated linear fraction of the UMIs of the genes of each module in each metacell, out of the total UMIs.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_metacells_modules_scaled_linear_fractions!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_metacells_modules_scaled_linear_fractions!","text":"function compute_metacells_modules_scaled_linear_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = false,\n)::Nothing\n\nThe estimated linear fraction of the UMIs of the genes of each module in each metacell, out of the total UMIs, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_metacells_modules_log_linear_fractions!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_metacells_modules_log_linear_fractions!","text":"function compute_metacells_modules_log_linear_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = false,\n)::Nothing\n\nThe log base 2 of the estimated linear fraction of the UMIs of the genes of each module in each metacell, out of the total UMIs. This adds the gene_fraction_regularization to deal with zero fractions.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_metacells_modules_log_scaled_linear_fractions!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_metacells_modules_log_scaled_linear_fractions!","text":"function compute_metacells_modules_log_scaled_linear_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = false,\n)::Nothing\n\nThe log base 2 of the estimated linear fraction of the UMIs of the genes of each module in each metacell, out of the total UMIs, scaled by divergence. This adds the gene_fraction_regularization to deal with zero fractions.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Linear-Covered-Fractions","page":"Analyze Modules","title":"Linear Covered Fractions","text":"","category":"section"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_metacells_modules_linear_covered_fractions!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_metacells_modules_linear_covered_fractions!","text":"function compute_metacells_modules_linear_covered_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = false,\n)::Nothing\n\nThe estimated linear fraction of the UMIs of the covered genes of each module in each metacell, out of the total covered UMIs.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_metacells_modules_scaled_linear_covered_fractions!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_metacells_modules_scaled_linear_covered_fractions!","text":"function compute_metacells_modules_scaled_linear_covered_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = false,\n)::Nothing\n\nThe estimated linear fraction of the UMIs of the covered genes of each module in each metacell, out of the total covered UMIs, scaled by divergence.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_metacells_modules_log_linear_covered_fractions!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_metacells_modules_log_linear_covered_fractions!","text":"function compute_metacells_modules_log_linear_covered_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = false,\n)::Nothing\n\nThe log base 2 of the estimated linear fraction of the UMIs of the covered genes of each module in each metacell, out of the total covered UMIs. This adds the gene_fraction_regularization to deal with zero fractions.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Metacells.AnalyzeModules.compute_metacells_modules_log_scaled_linear_covered_fractions!","page":"Analyze Modules","title":"Metacells.AnalyzeModules.compute_metacells_modules_log_scaled_linear_covered_fractions!","text":"function compute_metacells_modules_log_scaled_linear_covered_fractions!(\n    daf::DafWriter;\n    gene_fraction_regularization::AbstractFloat = ```1.0e-5```,\n    overwrite::Bool = false,\n)::Nothing\n\nThe log base 2 of the estimated linear fraction of the UMIs of the covered genes of each module in each metacell, out of the total covered UMIs, scaled by divergence. This adds the gene_fraction_regularization to deal with zero fractions.\n\n\n\n\n\n","category":"function"},{"location":"analyze_modules.html#Index","page":"Analyze Modules","title":"Index","text":"","category":"section"},{"location":"analyze_modules.html","page":"Analyze Modules","title":"Analyze Modules","text":"Pages = [\"analyze_modules.md\"]","category":"page"},{"location":"compute_approximation.html#Compute-Approximation","page":"Compute Approximation","title":"Compute Approximation","text":"","category":"section"},{"location":"compute_approximation.html#Metacells.ComputeApproximation","page":"Compute Approximation","title":"Metacells.ComputeApproximation","text":"Compute a local linear approximation to the manifold based on gene modules.\n\n\n\n\n\n","category":"module"},{"location":"compute_approximation.html#Metacells.ComputeApproximation.compute_blocks_modules_base_covered_fractions!","page":"Compute Approximation","title":"Metacells.ComputeApproximation.compute_blocks_modules_base_covered_fractions!","text":"function compute_blocks_modules_base_covered_fractions!(\n    daf::DafWriter;\n    overwrite::Bool = ```false```,\n)::Nothing\n\nThe base fractions used by the gene modules analysis. This is based on the per-gene base_covered_fraction.\n\nInputs\n\nAxes\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nmodule (required): A local (per block) gene module.\n\ngene (required): Sequenced genes.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\nMatrices\n\nblock, gene @ module_index::Union{UInt16, UInt32, UInt64, UInt8} (required): The index of the gene module each gene belongs to in the environment of each block.\n\nblock, gene @ basecoveredfraction::Union{Float32, Float64} (required): The base covered fractions used by the principal component analysis..\n\nOutputs\n\nMatrices\n\nblock, module @ basecoveredfraction::Union{Float32, Float64} (guaranteed): The base covered fractions used by the gene modules analysis..\n\n\n\n\n\n","category":"function"},{"location":"compute_approximation.html#Metacells.ComputeApproximation.compute_approximation!","page":"Compute Approximation","title":"Metacells.ComputeApproximation.compute_approximation!","text":"function compute_approximation!(\n    daf::DafWriter;\n    cross_validation_parts::Integer = ```5```,\n    rng::AbstractRNG = default_rng(),\n    overwrite::Bool = ```false```,\n)::Nothing\n\nFor each block, compute a local linear model for its environment, based on the used gene modules. This is a simple least-squares approximation predicting the fraction of the covered genes based on the fraction of the gene modules (using the base_covered_fraction of the modules in the environment). This is assumed to over-fit the solution, so we use cross-validation (in cross_validation_parts) using subsets of the metacells to compute both the RMSE and XRMSE to estimate this.\n\nnote: Note\nThis uses the virtual metacell_gene_covered_fraction_matrix. You will need an adapter to map these to concrete fractions (geomean, linear, scaled, ...).\n\nInputs\n\nAxes\n\ngene (required): Sequenced genes.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\nmodule (required): A local (per block) gene module.\n\nVectors\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\nMatrices\n\ngene, metacell @ covered_fraction::Union{Float32, Float64} (required): Some estimated fraction of the UMIs of each covered gene in each metacell.\n\nblock, block @ isinenvironment::Bool (required): For each block, the (column) mask of nearby blocks in its expanded environment.\n\nblock, block @ isinneighborhood::Bool (required): For each block, the (column) mask of nearby blocks in its immediate neighborhood.\n\nblock, gene @ module_index::Union{UInt16, UInt32, UInt64, UInt8} (required): The index of the gene module each gene belongs to in the environment of each block.\n\nblock, gene @ basecoveredfraction::Union{Float32, Float64} (required): The base covered fractions used by the principal component analysis..\n\nblock, module @ basecoveredfraction::Union{Float32, Float64} (required): The base covered fractions used by the gene modules analysis..\n\nblock, module @ is_used::Bool (required): Whether each gene module is used in the linear model of each block.\n\nOutputs\n\nVectors\n\nblock @ modules_RMSE::Union{Float32, Float64} (guaranteed): The root mean squared error of predicting the covered genes using the gene modules in the vicinity of the block.\n\nblock @ modules_XRMSE::Union{Float32, Float64} (guaranteed): The cross-validated root mean squared error of predicting the covered genes using the gene modules in the vicinity of the block.\n\nTensors\n\nblock; module, gene @ covered_coefficient::Union{Float32, Float64} (guaranteed): The coefficient of each gene module for computing each covered gene.\n\n\n\n\n\n","category":"function"},{"location":"compute_approximation.html#Index","page":"Compute Approximation","title":"Index","text":"","category":"section"},{"location":"compute_approximation.html","page":"Compute Approximation","title":"Compute Approximation","text":"Pages = [\"compute_approximation.md\"]","category":"page"},{"location":"compute_approximation.html#Model","page":"Compute Approximation","title":"Model","text":"","category":"section"},{"location":"sharpen_metacells.html#Sharpen-Metacells","page":"Sharpen Metacells","title":"Sharpen Metacells","text":"","category":"section"},{"location":"sharpen_metacells.html#Metacells.SharpenMetacells","page":"Sharpen Metacells","title":"Metacells.SharpenMetacells","text":"Compute \"better\" metacells based on the local linear model approximating the manifold.\n\n\n\n\n\n","category":"module"},{"location":"sharpen_metacells.html#Metacells.SharpenMetacells.sharpen_metacells!","page":"Sharpen Metacells","title":"Metacells.SharpenMetacells.sharpen_metacells!","text":"function sharpen_metacells!(\n    original::DafReader,\n    sharpened::DafWriter;\n    scale::Bool = ```false```,\n    migrate::Bool = ```true```,\n    min_downsamples::Integer = ```750```,\n    min_downsamples_quantile::AbstractFloat = ```0.05```,\n    max_downsamples_quantile::AbstractFloat = ```0.5```,\n    min_cells_in_metacell::Integer = ```12```,\n    min_migrated_cells_fraction::AbstractFloat = ```0.01```,\n    kmeans_rounds::Integer = ```10```,\n    rng::AbstractRNG = default_rng(),\n    overwrite::Bool = ```false```,\n)::Nothing\n\nGiven an original repository with a local linear model approximating the manifold, compute new metacells into the sharpened repository, which hopefully more faithfully capture this manifold.\n\nTODOX\n\nOriginal Metacells\n\nInputs\n\nAxes\n\ncell (required): Sequenced single cells.\n\nmetacell (required): Minimal-sized groups of cells for robust point estimates.\n\nblock (required): Distinct groups of metacells with \"very close\" estimated cell state.\n\ngene (required): Sequenced genes.\n\nmodule (required): A local (per block) gene module.\n\nVectors\n\ncell @ metacell::AbstractString (required): The unique metacell each cell belongs to.\n\nmetacell @ block::AbstractString (required): The unique block each metacell belongs to.\n\ngene @ is_covered::Bool (required): A mask of genes that are covered by the local linear program.\n\nMatrices\n\ngene, cell @ UMIs::Union{UInt16, UInt32, UInt64, UInt8} (required): The number of UMIs collected for each gene for each cell.\n\nblock, gene @ module_index::Union{UInt16, UInt32, UInt64, UInt8} (required): The index of the gene module each gene belongs to in the environment of each block.\n\nblock, module @ is_used::Bool (required): Whether each gene module is used in the linear model of each block.\n\nblock, block @ isinneighborhood::Bool (optional): For each block, the (column) mask of nearby blocks in its immediate neighborhood.\n\nSharpened Metacells\n\nInputs\n\nAxes\n\ncell (required): Sequenced single cells.\n\nOutputs\n\nAxes\n\nmetacell (guaranteed): Minimal-sized groups of cells for robust point estimates.\n\nVectors\n\ncell @ metacell::AbstractString (guaranteed): The unique metacell each cell belongs to.\n\nmetacell @ block::AbstractString (guaranteed): The unique block each metacell belongs to.\n\n\n\n\n\n","category":"function"},{"location":"sharpen_metacells.html#Index","page":"Sharpen Metacells","title":"Index","text":"","category":"section"},{"location":"sharpen_metacells.html","page":"Sharpen Metacells","title":"Sharpen Metacells","text":"Pages = [\"sharpen_metacells.md\"]","category":"page"},{"location":"index.html#Metacells","page":"Metacells","title":"Metacells","text":"","category":"section"},{"location":"index.html#Metacells.Metacells","page":"Metacells","title":"Metacells.Metacells","text":"The Metacells.jl package provides computational services for the metacells package, using Daf to hold the data. In the future, we'll ideally migrate all of the metacellspackage computations to this package, converting the Python package to a thin wrapper, and provide a similar thin R wrapper to provide metacell analysis from R as well. For now,Metacells.jlonly provides a subset of the features of the Pythonmetacellspackage, which requires users to convert data fromAnnData(for the old features) to Daf (to the new features).\n\n\n\n\n\n","category":"module"},{"location":"index.html#Index","page":"Metacells","title":"Index","text":"","category":"section"},{"location":"index.html","page":"Metacells","title":"Metacells","text":"","category":"page"}]
}
